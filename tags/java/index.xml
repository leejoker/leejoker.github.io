<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on ESPIER</title>
    <link>http://leejoker.github.io/tags/java/</link>
    <description>Recent content in java on ESPIER</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 05 Sep 2019 17:51:10 +0800</lastBuildDate>
    
	<atom:link href="http://leejoker.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Js整型的坑</title>
      <link>http://leejoker.github.io/post/js%E6%95%B4%E5%9E%8B%E7%9A%84%E5%9D%91/</link>
      <pubDate>Thu, 05 Sep 2019 17:51:10 +0800</pubDate>
      
      <guid>http://leejoker.github.io/post/js%E6%95%B4%E5%9E%8B%E7%9A%84%E5%9D%91/</guid>
      <description>&lt;h2 id=&#34;js整型的坑&#34;&gt;JS整型的坑&lt;/h2&gt;

&lt;p&gt;昨天同事跟我说js在整型长度支持上有坑，我去查了一下确实是有些坑的。js对于数值的保存遵循&lt;a href=&#34;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&#34;&gt;IEEE 754 双精度浮点格式&lt;/a&gt;规范，采用了双精度存储，占用64bit。如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/1236px-IEEE_754_Double_Floating_Point_Format.svg.png&#34; alt=&#34;存储格式示意图，取自wiki&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用gradle打可执行jar包</title>
      <link>http://leejoker.github.io/post/%E4%BD%BF%E7%94%A8gradle%E6%89%93%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85/</link>
      <pubDate>Mon, 26 Aug 2019 13:35:04 +0800</pubDate>
      
      <guid>http://leejoker.github.io/post/%E4%BD%BF%E7%94%A8gradle%E6%89%93%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近的一个项目里面需要使用gradle打一个可执行的jar包，在网上看了一堆帖子照着做最后都不是很成功，最后终于参考StackOverflow上的帖子搞定了可执行jar包的打包脚本，因此做一个笔记对这个进行一下记录。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记一次登录假死的异常排查</title>
      <link>http://leejoker.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E5%81%87%E6%AD%BB%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Tue, 28 May 2019 09:35:11 +0800</pubDate>
      
      <guid>http://leejoker.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E5%81%87%E6%AD%BB%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;事件的起因源自一次客户现场的调试，调试到一半，客户说办公系统突然登录不进去了Σ(っ °Д °;)っ，当时因为手头上的事还没有搞定，就顺手把客户的tomcat重启了，然后似乎就一切正常，我也没有太放在心上。然鹅，事情并没有这么简单。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据结构与算法学习系列(二)</title>
      <link>http://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/</link>
      <pubDate>Tue, 05 Feb 2019 22:36:10 +0000</pubDate>
      
      <guid>http://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/</guid>
      <description>&lt;h1 id=&#34;线性表&#34;&gt;线性表&lt;/h1&gt;

&lt;p&gt;线性表是一个存储相同类型数据元素的有限序列。&lt;br /&gt;
这里面需要关注的两个点就是，相同类型的数据、有限序列。&lt;/p&gt;

&lt;p&gt;线性表包含两种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;顺序表。使用一段地址连续的存储单元依次存储线性表的数据元素。&lt;/li&gt;
&lt;li&gt;链表。使用一组任意的存储单元存放线性表的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;顺序表&#34;&gt;顺序表&lt;/h1&gt;

&lt;h2 id=&#34;顺序表的特性&#34;&gt;顺序表的特性&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;顺序表使用的一段连续的存储空间，因此只要知道存储顺序表的起始地址，就可以计算表中任意位置元素的地址。所以，&lt;strong&gt;计算任意一个元素的存储地址的时间是相等的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于上述特性，顺序表具有随机存取的特性。&lt;/li&gt;
&lt;li&gt;顺序表存取操作的时间复杂度为O(1)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;顺序表的实现&#34;&gt;顺序表的实现&lt;/h2&gt;

&lt;p&gt;下面就是一个简单的顺序表的实现：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据结构与算法学习系列（一）</title>
      <link>http://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/</link>
      <pubDate>Sun, 03 Feb 2019 21:17:44 +0000</pubDate>
      
      <guid>http://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/</guid>
      <description>&lt;h2 id=&#34;关于新坑和旧坑的说明&#34;&gt;关于新坑和旧坑的说明&lt;/h2&gt;

&lt;p&gt;我又开了一个新的坑，迫于近期一些方面的压力，我又把数据结构和算法这个东西捡起来了，至于之前Clojure学习笔记系列的坑，咳咳，虽然还会更新下去，但是估计会延后很多了，因为学了Clojure蛮久的时间了，没有太多的实践机会，也没有对Clojure理解的足够深，因此这个系列估计会稍微放一放，等我理解足够深刻了在继续下去（对不起，还是因为懒XD）。&lt;/p&gt;

&lt;h2 id=&#34;什么是算法&#34;&gt;什么是算法&lt;/h2&gt;

&lt;p&gt;算法，这个东西其实是思路的体现，也可以说是问题的解决方案。相信大家也都看到过这句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;程序=算法+数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然这么说或许不够准确，但是算法对于程序本身而言意义是十分重大的。也是影响程序性能的一个关键因素。大多时候算法都是一个由实际问题转化而成的数学模型，因此，像写出一个好的算法的话首先要能充分理解问题，然后就是将问题转化成一个高效的数学模型。所以说啊，学好数学还是很关键滴~&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>