<<<<<<< HEAD
[{"content":"msys2启动加速 msys2安装以后，每次启动都需要等待很久，查了一下，配置如下：\n$ mkpasswd -c \u0026gt; /etc/passwd\r# 修改 /etc/nsswitch.conf， passwd所在行进行如下修改：\rpasswd: files db \u0026lt;- files\r","date":"2023-06-07","permalink":"https://leejoker.github.io/post/msys2%E5%90%AF%E5%8A%A8%E5%8A%A0%E9%80%9F/","tags":["Windows","msys2"],"title":"Msys2启动加速"},{"content":"篇首语 好久没写博客了，最近公司的事情搞得我一个头两个大，不禁感慨，PM真的不是人干的活啊（当PM的小伙伴别打我 XD）。\n算了，闲话少叙，还是说说为啥写减肥吧。\n说到减肥，其实应该是不少小伙伴们比较关心的话题（当然，如果你不关心这个话题也请关注一下自己的体重，和体重带给自己的外貌、身体状况、求偶等多方面的影响，以及这些影响是正面的？还是负面的？），尤其是在工作以后，别的先不说，小肚子肯定有的。我身边的同事有的也很瘦，但是小肚子真的是一个比一个大。随之而来的，就是脂肪肝等等一堆肥胖带来的并发症。。。\n似乎扯远了，我也不打算说肥胖带来的问题，主要还是讲讲自己减肥的缘由和关于减肥的一些想法。\n缘起 想要减肥的原因很简单，就是怕死~\n听起来似乎有点扯，但是确实如此。\n起因是2017年去深圳出差。那一个月的加班可能让我毕生难忘。每天9点开工，干到凌晨三点，偶尔通宵，持续一月。干到最后阶段的时候，项目终于是脱离了危险，但是感觉人快没了，有的时候不禁怀疑，刚才心脏是不是漏拍了QAQ。除了加班，还有就是饮食问题了，因为那个时候不太节制，再加上我本人相当能吃，所以体重自然噌噌噌的长了上去。回到帝都之后，家人一度怀疑是不是打了激素，不然怎么会催肥催的如此显著 XD。\n自那之后，我决定，一定要减下去！\n然而过程大多数时候是很艰难且容易放弃的 正如这一节的标题所言，过程大多数时候都是艰难且容易放弃的。慢跑刚开始我是拒绝的，真的枯燥，所以我选择了跳绳。然而也没坚持多久。随后是Keep和健身环，但是始终强度不够。不过可能是基数够大，也很快减了5公斤左右，然后就因为工作和自身的一些原因，减肥就搁置了。\n随后是2019年，我2月份和同事办了健身卡，然后控制饮食，一周三到四天健身房，每天20~30分钟撸铁（刚开始必然是很菜的，后面慢慢好了点），40~60分钟慢跑，随后是拉伸。这段时间是给我减肥树立信心的过程，因为真的减下来了，大概2个月的时间，瘦了将近10公斤！不过，之后的疯狂加班直接导致我的减肥破产，而且反弹了回去（熬夜、宵夜这两个真的要不得，加班还不能太控制饮食，饿着肚子加班，根本没法干活），这个结果也直接导致我选择了离职（不过主要原因是加班和钱少XD）。\n在之后就是今年5月份到现在了，更换了工作之后，明显安逸了不少，然而这也导致我的体重十分稳定，减肥终于再次被我提上了日程。\n这次我没有选择健身房，没有选择Keep之类的软件，很简单，就是跑步，从500米喘得够呛到5公里能够一次性跑完，这个过程真的是痛苦又充满成就感的，我逐渐喜欢上了跑步，喜欢上了跑完以后浑身酸爽的感觉。\n成果 目前就成果而言还算显著，已经减下去了10公斤左右（93.7 -\u0026gt; 83.5），而且应该还没有到平台期，通过控制每天摄入的能量和消耗应该还能继续减下去。\n肌肉的话应该也掉了一些，不过其实这些我都不是很在意，先减下去再说吧，肌肉注意蛋白质的摄入和适当肌肉训练应该不至于掉的太厉害，第一要务还是把体脂减下去。\n一些心得 不要追求速度，不要追求距离，调整好运动的心态是第一要务，只有想去运动，能够保持才是最关键的。 适当的步速：慢跑看中的还是运动的时间，距离什么的不重要，能够有配合呼吸的步速才能坚持下去。 意志力 这个是我前期跑不了太远的问题，一定要坚持哪怕很累的也要完成预定的目标。（当然，目标可以根据每天身体状态调整，但是一定要完成） 第二个方面就是一定要管住嘴，晚上一定杜绝诱惑，如果想吃尽量早吃，且不要太多，根据跑步的距离衡量热量的摄入（这一点务必慎重，不要养成不好的习惯） 减少碳水，杜绝暴饮暴食 放在最后 扯了这么多，无非是炫耀一下减肥的成果，然后给自己加油打气~（不过也好像没啥可炫耀的，瘦了不少，但是体脂还是挺高）\n坚持，才可能有所收获，与诸君共勉~\n","date":"2021-08-11","permalink":"https://leejoker.github.io/post/%E5%85%B3%E4%BA%8E%E8%BF%90%E5%8A%A8%E5%87%8F%E8%82%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/","tags":["杂文"],"title":"关于运动减肥的一些经验之谈"},{"content":"首先来吐槽一波(╯‵□′)╯︵┻━┻ 本来呢，我是想加一层feign的interceptor处理feign里request请求的返回信息的，比如只提取ResponseBody中的data啥的。后来想起来feign默认使用的是jdk的HttpURLConnection，而且feign本身是支持替换okhttp的，于是打算搞起~\n可是，百毒到的都是什么鬼啊，按照别人写的文档配好，各种问题，什么springboot注解不行啦，需要使用feign默认注解，什么负载均衡失效啦，无语。(╯‵□′)╯︵┻━┻\n最后，还是自己操刀，从源码看吧。\n遂有此文~\n百毒，淦！\n首先来写一个简单的interceptor 不需要这个的跳过看下一段吧~\n//这个interceptor的目的是提取返回body中的data，并转化为json\r@Component\rpublic class OkHttpResponseInterceptor implements Interceptor {\r@Override\rpublic Response intercept(Chain chain) throws IOException {\rRequest request = chain.request();\rResponse response = chain.proceed(request);\rif (HttpHeaders.hasBody(response)) {\rif (response.code() == 200) {\rResponseBody responseBody = response.body();\rif (responseBody != null\r\u0026amp;\u0026amp; responseBody.contentLength() != 0\r\u0026amp;\u0026amp; Objects.requireNonNull(responseBody.contentType()).type()\r.equals(MediaType.APPLICATION_JSON_VALUE)) {\rString str = responseBody.string();\rJSONObject json = JSONObject.parseObject(JSON.toJSON(str));\rString data = json.getString(\u0026quot;data\u0026quot;);\rif (StringUtils.isNotBlank(data)) {\rResponseBody body = ResponseBody.create(okhttp3.MediaType.get(MediaType.APPLICATION_JSON_VALUE), data);\rreturn response.newBuilder().body(body).build();\r}\r}\r}\r}\rreturn response;\r}\r}\r嗯，这样，interceptor就定义好了，接下来就是配置feign了~\n配置Feign 关于maven依赖修改啥的我就不说了，如果使用的spring-cloud-openfeign-dependencies，应该会包含okhttp的依赖。\n修改application.yml\nfeign:\rhystrix:\renabled: true\rokhttp:\renabled: true\rhttpclient:\rconnectionTimeout: 30000\rclient:\rconfig:\rdefault:\rreadTimeout: 30000\r添加FeignOkHttpConfig.java\n@Configuration\r@ConditionalOnClass(Feign.class)\r@AutoConfigureBefore(FeignLoadBalancerAutoConfiguration.class)\rpublic class FeignOkHttpConfig {\r@Autowired\rprivate OkHttpResponseInterceptor okHttpResponseInterceptor;\rprivate okhttp3.OkHttpClient okHttpClient;\r@Bean\r@ConditionalOnMissingBean(ConnectionPool.class)\rpublic ConnectionPool httpClientConnectionPool(\rFeignHttpClientProperties httpClientProperties,\rOkHttpClientConnectionPoolFactory connectionPoolFactory) {\rInteger maxTotalConnections = httpClientProperties.getMaxConnections();\rLong timeToLive = httpClientProperties.getTimeToLive();\rTimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit();\rreturn connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);\r}\r@Bean\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\rpublic okhttp3.OkHttpClient okHttpClient(OkHttpClientFactory httpClientFactory,\rConnectionPool connectionPool,\rFeignClientProperties feignClientProperties,\rFeignHttpClientProperties feignHttpClientProperties) {\rFeignClientProperties.FeignClientConfiguration defaultConfig = feignClientProperties.getConfig().get(\u0026quot;default\u0026quot;);\rint connectTimeout = feignHttpClientProperties.getConnectionTimeout();\rint readTimeout = defaultConfig.getReadTimeout();\rboolean disableSslValidation = feignHttpClientProperties.isDisableSslValidation();\rboolean followRedirects = feignHttpClientProperties.isFollowRedirects();\rthis.okHttpClient = httpClientFactory.createBuilder(disableSslValidation)\r.readTimeout(readTimeout, TimeUnit.MILLISECONDS)\r.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)\r.followRedirects(followRedirects)\r.connectionPool(connectionPool)\r.addInterceptor(okHttpResponseInterceptor)\r.build();\rreturn this.okHttpClient;\r}\r@PreDestroy\rpublic void destroy() {\rif (this.okHttpClient != null) {\rthis.okHttpClient.dispatcher().executorService().shutdown();\rthis.okHttpClient.connectionPool().evictAll();\r}\r}\r}\r好的~ 这样基本上就配置完了。下面我来具体解释一下，这么配置就能生效的原因。（如果不需要负载均衡，可以参考百毒到的配置方案，那个应该也是ok的）\n解析 什么条件下配置的okhttp才会生效\n首先看org.springframework.cloud.openfeign.FeignAutoConfiguration\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnClass(OkHttpClient.class)\r@ConditionalOnMissingClass(\u0026quot;com.netflix.loadbalancer.ILoadBalancer\u0026quot;)\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\r@ConditionalOnProperty(\u0026quot;feign.okhttp.enabled\u0026quot;)\rprotected static class OkHttpFeignConfiguration {\r...\r}\r只有当okhttp3.OkHttpClient这个Bean不存在时，才会启用OkHttpFeignConfiguration。\n然而我们在配置中需要修改interceptor必然会手动创建这个Bean，因此我们需要手动添加其他的配置。\n但是，先不要急，因为如果使用负载均衡，这个类还不是关键。\nfeign负载均衡FeignLoadBalancerAutoConfiguration\n@ConditionalOnClass(Feign.class)\r@ConditionalOnBean(BlockingLoadBalancerClient.class)\r@AutoConfigureBefore(FeignAutoConfiguration.class)\r@AutoConfigureAfter(FeignRibbonClientAutoConfiguration.class)\r@EnableConfigurationProperties(FeignHttpClientProperties.class)\r@Configuration(proxyBeanMethods = false)\r// Order is important here, last should be the default, first should be optional\r// see\r// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653\r@Import({ HttpClientFeignLoadBalancerConfiguration.class,\rOkHttpFeignLoadBalancerConfiguration.class,\rDefaultFeignLoadBalancerConfiguration.class })\rpublic class FeignLoadBalancerAutoConfiguration {\r}\r不难发现，这个配置加载是在FeignAutoConfiguration之前的，因此，这个类对于我们而言更为关键。\n@Import({ HttpClientFeignLoadBalancerConfiguration.class,\rOkHttpFeignLoadBalancerConfiguration.class,\rDefaultFeignLoadBalancerConfiguration.class })\r通过Import注解的信息，我们得知需要查看OkHttpFeignLoadBalancerConfiguration。\n根据OkHttpFeignLoadBalancerConfiguration\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnClass(OkHttpClient.class)\r@ConditionalOnProperty(\u0026quot;feign.okhttp.enabled\u0026quot;)\r@ConditionalOnBean(BlockingLoadBalancerClient.class)\r@Import(OkHttpFeignConfiguration.class)\rclass OkHttpFeignLoadBalancerConfiguration {\r@Bean\r@ConditionalOnMissingBean\rpublic Client feignClient(okhttp3.OkHttpClient okHttpClient,\rBlockingLoadBalancerClient loadBalancerClient) {\rOkHttpClient delegate = new OkHttpClient(okHttpClient);\rreturn new FeignBlockingLoadBalancerClient(delegate, loadBalancerClient);\r}\r}\r可以看出，这个配置类只生成了Client这个Bean，对于FeignAutoConfiguration中需要的剩下的Bean显然是不够的，因此，剩下的内容应该都在\n@Import(OkHttpFeignConfiguration.class)\r这个Import的配置中，那么我们看看这个配置到底做了啥。\n最后一步了~\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\rpublic class OkHttpFeignConfiguration {\rprivate okhttp3.OkHttpClient okHttpClient;\r@Bean\r@ConditionalOnMissingBean(ConnectionPool.class)\rpublic ConnectionPool httpClientConnectionPool(\rFeignHttpClientProperties httpClientProperties,\rOkHttpClientConnectionPoolFactory connectionPoolFactory) {\rInteger maxTotalConnections = httpClientProperties.getMaxConnections();\rLong timeToLive = httpClientProperties.getTimeToLive();\rTimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit();\rreturn connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);\r}\r@Bean\rpublic okhttp3.OkHttpClient client(OkHttpClientFactory httpClientFactory,\rConnectionPool connectionPool,\rFeignHttpClientProperties httpClientProperties) {\rBoolean followRedirects = httpClientProperties.isFollowRedirects();\rInteger connectTimeout = httpClientProperties.getConnectionTimeout();\rthis.okHttpClient = httpClientFactory\r.createBuilder(httpClientProperties.isDisableSslValidation())\r.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)\r.followRedirects(followRedirects).connectionPool(connectionPool).build();\rreturn this.okHttpClient;\r}\r@PreDestroy\rpublic void destroy() {\rif (this.okHttpClient != null) {\rthis.okHttpClient.dispatcher().executorService().shutdown();\rthis.okHttpClient.connectionPool().evictAll();\r}\r}\r}\r很显然，这个类才是我们需要替换的，而且这个配置类的加载条件很简单\n@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\r我们只要自己创建这个Bean就可以了。\n那么，我们要做的就是在FeignLoadBalancerAutoConfiguration配置类加载之前，生成这个Bean，并根据OkHttpFeignConfiguration生成其他需要的Bean就可以了。具体参考 配置Feign 一节。\n","date":"2021-04-06","permalink":"https://leejoker.github.io/post/feign%E4%BD%BF%E7%94%A8okhttp3%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/","tags":["springcloud","feign"],"title":"Feign使用okhttp3的正确姿势"},{"content":" 添加apt源到/etc/apt/sources.list文件\n$ sudo echo \u0026quot;deb [arch=amd64] http://packages.microsoft.com/repos/vscode stable main\u0026quot; \u0026gt;\u0026gt; /etc/apt/sources.list\r添加gpg公钥\n$ sudo curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; /etc/apt/trusted.gpg.d/microsoft.gpg\r如果提示找不到curl执行命令，请先安装curl\n$ sudo apt install curl\r执行更新\n$ sudo apt update\r安装vscode\n$ sudo apt install code\r这样就可以通过apt命令对vscode进行更新了。\n以上~\n","date":"2021-03-08","permalink":"https://leejoker.github.io/post/ubuntu%E6%B7%BB%E5%8A%A0vscode%E6%BA%90/","tags":["linux","ubuntu","vscode"],"title":"Ubuntu添加vscode源"},{"content":"在项目中设置国内仓库 修改project.clj，参考如下内容进行设置\n(defproject project-name :dependencies [[org.clojure/clojure \u0026quot;1.10.0\u0026quot;]] :repositories [[\u0026quot;central\u0026quot; \u0026quot;http://maven.aliyun.com/nexus/content/groups/public\u0026quot;] [\u0026quot;clojars\u0026quot; \u0026quot;https://mirrors.tuna.tsinghua.edu.cn/clojars/\u0026quot;]]) ;; 这个是官方的启用非严格检查方案 (require 'cemerick.pomegranate.aether) (cemerick.pomegranate.aether/register-wagon-factory! \u0026quot;http\u0026quot; #(org.apache.maven.wagon.providers.http.HttpWagon.)) 7-10行的内容放在project.clj文件的最后，主要用于关闭高版本lein的严格仓库检查（非必需）。\n感谢音无麻里亚在Blog中提供的解决方案~~\n配置全局国内仓库 {:user {:mirrors { \u0026quot;central\u0026quot; {:name \u0026quot;aliyun\u0026quot; :url \u0026quot;https://maven.aliyun.com/repository/public/\u0026quot;} #\u0026quot;clojars\u0026quot; {:name \u0026quot;qinghua\u0026quot; :url \u0026quot;https://mirrors.tuna.tsinghua.edu.cn/clojars/\u0026quot; :repo-manager true} } :plugins [] :repl-options {:init (use 'midje.repl)} ;; :injections [(require 'cemerick.pomegranate.aether) ;; (cemerick.pomegranate.aether/register-wagon-factory! ;; \u0026quot;http\u0026quot; #(org.apache.maven.wagon.providers.http.HttpWagon.))] :dependencies [[midje \u0026quot;1.9.9\u0026quot;]] } } 感谢onedam在Blog中提供的解决方案~~\n特别说明 本文内容基本上都是转自网络，也附上了作者的地址和原文，感兴趣的同学可以去看看。\n我这里只是做个笔记，方便内容的整理和查询。\n以上。\n","date":"2021-03-04","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AEclojure%E5%9B%BD%E5%86%85%E4%BB%93%E5%BA%93/","tags":["clojure"],"title":"配置Clojure国内仓库"},{"content":"windows下转发虚拟机中的服务 PC C:\\Users\\leejoker\u0026gt; netsh interface portproxy add v4tov4 listenport=8080 listenaddress=10.10.1.233 connectport=8080 connectaddress=192.168.0.233 这个命令即可实现将虚拟机中的服务映射出去。\nlistenport：物理机监听端口，其他局域网内的机器通过这个端口访问虚拟机中的服务 listenaddress：物理机监听的地址，本机ip connectport：虚拟机中服务暴露给本机的端口 connect address：虚拟机映射到本机的ip地址 其他命令参考 查看所有端口转发\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy show all 删除端口转发配置（删除时需要增加类型参数，例如v4tov4）\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=10.10.1.233 清空端口转发配置\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy reset 结语 这个功能在windows里还是很好用的，尤其是需要在虚拟机里跑服务，你需要透传给同事进行测试的时候XD\n如果你不知道怎么把虚拟机里的服务映射到物理机，那么你可以去百度，或者用vagrant构建虚拟机。\n","date":"2021-01-11","permalink":"https://leejoker.github.io/post/windows%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","tags":["windows"],"title":"Windows端口转发"},{"content":"具体操作 添加docker group $ sudo groupadd docker 添加用户到group $ sudo gpasswd -a ${USER} docker 重启服务 $ sudo service docker restart 补充说明 这种方式适用于当root用户或者使用sudo可以执行，但普通用户无法执行的场景，不仅限于docker这一个服务，其他服务遇到此类情况的时候也不妨试一试~\n","date":"2020-12-29","permalink":"https://leejoker.github.io/post/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cdocker%E5%91%BD%E4%BB%A4/","tags":["linux"],"title":"普通用户直接运行docker命令"},{"content":"IDEA升级到2020.3后，使用lombok会报以下错误：\njava: You aren't using a compiler supported by lombok, so lombok will not work and has been disabled.\rYour processor is: com.sun.proxy.$Proxy24\rLombok supports: sun/apple javac 1.6, ECJ\r这个问题需要将lombok升级到1.18.16版本：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r解决！\n","date":"2020-12-07","permalink":"https://leejoker.github.io/post/idea%E5%8D%87%E7%BA%A72020.3%E5%90%8Elombok%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/","tags":["idea","技巧"],"title":"IDEA升级2020.3后lombok编译报错"},{"content":"起因 最开始是因为出差要跑公司的项目，为了省事在笔记本上装了Docker Desktop for Windows和docker版本的mysql，因为docker依赖hyper-v虚拟化，所以我就把他打开了。\n然后。。。我就发现，mumu模拟器居然不支持在开启hyper-v环境下启动，(╯‵□′)╯︵┻━┻，于是我几番折腾，找到了BlueStacks Hyper-V(测试版本)！\n当时我非常开心，以为终于找到了解决方案，于是开始安装FGO，运行，闪退。。。运行，闪退。。。。(╯‵□′)╯︵┻━┻\n无果，\u0026quot;[docker] 一遍、死んで见る\u0026quot;，docker 卒！\nvagrant搞起！谁也阻挡不了我玩FGO，现在可是无限池！！！\n开始安装吧！はじまるよ sudo apt install mysql-server\r# 记得做好备份\rsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\r# 示例如下\r[mysqld]\rskip-grant-tables\rlower_case_table_names=1\ruser\t= mysql\rpid-file\t= /var/run/mysqld/mysqld.pid\rsocket\t= /var/run/mysqld/mysqld.sock\rport\t= 3306\rdatadir\t= /var/lib/mysql\rbind-address\t= 0.0.0.0\rmysqlx-bind-address\t= 0.0.0.0\rkey_buffer_size\t= 16M\rmyisam-recover-options = BACKUP\rlog_error = /var/log/mysql/error.log\rmax_binlog_size = 100M\r重启mysql服务\nsudo service mysql restart\r登录mysql，将root用户密码重置为空\nmysql -u root\r# 登录mysql后\ruse mysql\rupdate user set authentication_string='',host='%' where User='root';\rupdate user set plugin=\u0026quot;mysql_native_password\u0026quot;;\rflush privileges;\rexit\r修改配置文件后，重启服务\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\r[mysqld]\r# skip-grant-tables 修改这一行就行\rsudo service mysql restart\r登录mysql\nmysql -u root -p\r# 这时候依旧不需要输入密码，直接回车，接下来要设置密码了\ralter user 'root'@'%' identified by 'NewP@ssword';\rflush privileges;\rexit\r# 再登录就需要输入密码了\rmysql -u root -p\rshow databases;\r# 如果到这里一切正常，那就没什么问题了\r# 如果提示 The user specified as a definer ('mysql.infoschema'@'localhost') does not exist\r# 请尝试执行一下操作\rmysql -u root -p\rupdate user set plugin = 'caching_sha2_password' where user='mysql.sys' or user='mysql.infoschema';\rexit\r结语 安装的过程中折腾了好几次吧，不知道为啥我用sudo居然不能启动mysql服务，必须使用root用户，就很奇怪，估计和vagrant环境有关，也懒得处理这个问题了。希望能帮助到其他学习的小伙伴，帮不上别人就权当笔记了，毕竟是我2020年下半年第一篇blog XD！\n","date":"2020-12-05","permalink":"https://leejoker.github.io/post/ubuntu%E5%AE%89%E8%A3%85mysql8/","tags":["linux","mysql"],"title":"Ubuntu安装mysql8"},{"content":"由于公司的网络问题，我用CCProxy挂了一个代理在能上网的机器上，利用代理上网。这两天对rust感兴趣，于是就开始按照官网的说明安装rustup。\n然后，问题来了！挂的代理居然不能访问！\n# vim /etc/environment\r1 PATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/game\r2 http_proxy=\u0026quot;http://ip:port\u0026quot;\r3 https_proxy=\u0026quot;https://ip:port\u0026quot;\r4 ftp_proxy=\u0026quot;ftp://ip:port\u0026quot;\r5 socks_proxy=\u0026quot;socks://ip:port\u0026quot;\r6 no_proxy=\u0026quot;localhost,127.0.0.1,localaddress,.localdomain.com\u0026quot;\r在别的命令里面都是ok的，但是rustup这里就是不行。\n最后试了好久，发现像下面这么改就可以了，实在是百思不得其解，嘛~姑且记一下。\n# vim /etc/environment\r1 PATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/game\r2 http_proxy=ip:port\r3 https_proxy=ip:port\r4 ftp_proxy=ip:port\r5 socks_proxy=ip:port\r6 no_proxy=\u0026quot;localhost,127.0.0.1,localaddress,.localdomain.com\u0026quot;\r","date":"2020-01-28","permalink":"https://leejoker.github.io/post/rustup%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","tags":["rust"],"title":"Rustup代理设置"},{"content":"这两天发现我在.gitignore文件中添加忽略后，每次提交已经被忽略的文件还是会出现在我的提交列表里，查了一下，应该是git缓存的问题，只要清理一下缓存就ok了。\n$ cd $YOUR_PROJECT_DIR\r$ git rm -r --cached .\r$ git add .\r$ git commit -m 'update .gitignore'\r","date":"2020-01-28","permalink":"https://leejoker.github.io/post/idea%E4%B8%AD%E7%9A%84git%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%BF%BD%E7%95%A5.gitignore%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9/","tags":["idea","技巧"],"title":"Idea中的Git无法正常忽略"},{"content":"安装rvm # 安装gnupg2\r$ sudo apt install gnupg2\r# 安装rvm\r$ gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\r$ \\curl -sSL https://get.rvm.io | bash -s stable\r$ source ~/.bashrc\r# 替换ruby-china源\r$ echo \u0026quot;ruby_url=https://cache.ruby-china.com/pub/ruby\u0026quot; \u0026gt; ~/.rvm/user/db\r# 替换gem源\r$ gem sources -l\r$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/\r# 更新缓存\r$ gem sources -u 安装rbenv 当然如果网络不佳，安装不了rvm，也可以使用rbenv\n# rbenv源码\r$ git clone https://github.com/rbenv/rbenv.git ~/.rbenv\r# 用来编译安装 ruby\r$ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build\r# 用来管理 gemset, 可选, 因为有 bundler 也没什么必要\r$ git clone https://github.com/jamis/rbenv-gemset.git ~/.rbenv/plugins/rbenv-gemset\r# 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐\r$ git clone https://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update\r# 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐\r$ git clone https://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror\r# 将下面的内容放入 .bashrc\rexport PATH=\u0026quot;$HOME/.rbenv/bin:$PATH\u0026quot;\reval \u0026quot;$(rbenv init -)\u0026quot;\r$ source ~/.bashrc\r安装Ruby rvm # 列出ruby已知版本\r$ rvm list known\r# 安装\r$ rvm install 2.7.0 --disable-binary\r# 切换版本，并设为默认\r$ rvm use 2.7.0 --default\r# 卸载\r$ rvm remove 1.8.7\rrbenv\n#更新rbenv及插件\r$ rbenv update\r# 列出所有 ruby 版本\r$ rbenv install --list\r# 安装 2.7.0\r$ rbenv install 2.7.0\r# 卸载 2.7.0\r$ rbenv uninstall 2.7.0\r安装Rails $ gem install rails\r# 安装完成后查看rails版本\r$ rails -v\r写在最后 安装过程中如果存在依赖或者其他问题，请自觉检索吧，这个不同机器可能会有不同的情况。本文内容大量参考了ruby-china的wiki，十分感谢~\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/%E5%AE%89%E8%A3%85ruby-on-rails/","tags":["ruby","rails"],"title":"安装Ruby on Rails"},{"content":"Mapper中的使用 在insert中增加下面两个属性，useGeneratedKeys和keyProperty\nuseGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\r如果数据库支持自增主键，这样就可以了。如果不行，需要自己创建序列，然后通过序列获取主键值(使用的是postgresql中的函数，其他数据库视具体情况而定)：\n\u0026lt;insert id=\u0026quot;insertValue\u0026quot; parameterType=\u0026quot;map\u0026quot;\ruseGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\u0026gt;\r\u0026lt;selectKey keyProperty=\u0026quot;id\u0026quot; resultType=\u0026quot;java.lang.Long\u0026quot; order=\u0026quot;BEFORE\u0026quot;\u0026gt;\rSELECT nextval('sequence_name'::regclass) as id\r\u0026lt;/selectKey\u0026gt;\rinsert into table_name\r\u0026lt;trim prefix=\u0026quot;(\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt;\r\u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt;\rid,\r\u0026lt;/if\u0026gt;\r...\r\u0026lt;/trim\u0026gt;\r\u0026lt;trim prefix=\u0026quot;values (\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt;\r\u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt;\r#{id,jdbcType=BIGINT},\r\u0026lt;/if\u0026gt;\r...\r\u0026lt;/trim\u0026gt;\r\u0026lt;/insert\u0026gt;\r当然你也可以这样使用\n\u0026lt;insert id=\u0026quot;insertValue\u0026quot; parameterType=\u0026quot;map\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\u0026gt;\rinsert into table_name\r\u0026lt;trim prefix=\u0026quot;(\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt;\r\u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt;\rid,\r\u0026lt;/if\u0026gt;\r...\r\u0026lt;/trim\u0026gt;\r\u0026lt;trim prefix=\u0026quot;values (\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt;\r\u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt;\r(SELECT nextval('sequence_name'::regclass) as id),\r\u0026lt;/if\u0026gt;\r...\r\u0026lt;/trim\u0026gt;\r\u0026lt;/insert\u0026gt;\r这种使用方法也适用于批量执行插入的时候\n\u0026lt;insert id=\u0026quot;insertBatch\u0026quot; parameterType=\u0026quot;java.util.List\u0026quot;\u0026gt;\rinsert into table_name (\rid,\r...\r) values\r\u0026lt;foreach collection=\u0026quot;list\u0026quot; item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt;\r((SELECT nextval('sequence_name'::regclass) as id), ...)\r\u0026lt;/foreach\u0026gt;\r\u0026lt;/insert\u0026gt;\r","date":"2020-01-10","permalink":"https://leejoker.github.io/post/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E4%B8%BB%E9%94%AE/","tags":["mybatis","java"],"title":"Mybatis中使用序列自动插入主键"},{"content":"今天在开发过程中遇到一个文件上传的问题\nio.undertow.server.RequestTooBigException: UT000020: Connection terminated as request was larger than 10485760\rServlet容器使用的是undertow，看异常信息应该是默认存在10MB的文件大小限制。\n百度了一下，找到如下配置，问题得以解决，记录一下\nspring:\rservlet:\rmultipart:\r# 文件最大限制\rmax-file-size: 1024MB\r# 请求最大限制\rmax-request-size: 1024MB\renabled: true\r# 设置文件缓存的临界点,超过则先保存到临时目录,默认为0,所有文件都会进行缓存\rfile-size-threshold: 0\r","date":"2020-01-10","permalink":"https://leejoker.github.io/post/springboot%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E5%A4%84%E7%90%86/","tags":["java","springboot"],"title":"Springboot上传文件大小限制处理"},{"content":"获取Yapi源码 在github上获取最新的yapi源码：\n$ git clone https://github.com/YMFE/yapi.git ~/yapi\r通过npm或cnpm安装依赖：\n$ cd ~/yapi\r$ npm install\r这样准备工作就完成了一半了，接下来安装mongodb。\n安装和配置MongoDB（Ubuntu 18.04） 一些说明 这一部分建议读完之后再进行操作，有些操作可能会产生一些问题，为避免不必要的麻烦，特此声明！\n安装MongoDB服务端 安装MongoDB的服务端可以通过官网进行下载，记得选择与自己系统相匹配的版本\n下载完成后，可以使用dpkg命令进行安装\n$ sudo dpkg -i mongodb-org-server_4.2.2_amd64.deb\r创建mongodb的默认数据目录\n$ sudo mkdir -p /data/db\r运行mongodb\n$ sudo mongod\r这样，mongodb服务就启动了。\n安装MongoDB客户端 安装了服务端后，还要安装客户端才能够连接数据库进行控制，官网也提供了Mongo Shell，在Package处选择shell即可下载，不过由于是企业版本里的，我也没有去确认是否会收费，就没有尝试了。\n我用的是Ubuntu包管理里的mongodb-clients\n$ sudo apt install mongodb-clients\r安装完成后，运行客户端\n$ mongo\rPS：如果通过包管理安装了mongodb-clients，最好还是通过包管理安装mongodb，下载的服务端可能和包管理中的客户端版本不匹配，然后被包管理卸载掉服务端，/(ㄒoㄒ)/~~\n配置MongoDB 使用客户端连接mongodb后，需要创建yapi数据库\n\u0026gt; use yapi\r\u0026gt; db.yapi.insert({\u0026quot;name\u0026quot;:\u0026quot;init_data\u0026quot;})\r当然，你也可以用MongoDB Compass操作数据库。\n添加用户\n\u0026gt; use yapi\r\u0026gt; db.createUser({ user: \u0026quot;yapi\u0026quot;, pwd: \u0026quot;123456\u0026quot;, roles: [ { role: \u0026quot;dbOwner\u0026quot;, db: \u0026quot;yapi\u0026quot; } ]\r})\r如果发生\nError: couldn’t add user: Use of SCRAM-SHA-256 requires undigested passwords\n请增加 mechanisms 属性\n\u0026gt; use yapi\r\u0026gt; db.createUser({ user: \u0026quot;yapi\u0026quot;, pwd: \u0026quot;123456\u0026quot;,\rroles: [ { role: \u0026quot;dbOwner\u0026quot;, db: \u0026quot;yapi\u0026quot; } ],\rmechanisms : [\u0026quot;SCRAM-SHA-1\u0026quot;] })\r对新增的用户进行验证\n\u0026gt; use yapi\r\u0026gt; db.auth('yapi','123456')\r返回1的话就没有什么问题啦！记得一定要切换到对应数据库下建立用户！！！\n配置Yapi 创建config.json配置文件\n$ cd ~/yapi\r$ cp config_example.json config.json\r修改config.json文件\n{\r\u0026quot;port\u0026quot;: \u0026quot;3000\u0026quot;,\r\u0026quot;adminAccount\u0026quot;: \u0026quot;you_email_address@email.com\u0026quot;,\r\u0026quot;db\u0026quot;: {\r\u0026quot;servername\u0026quot;: \u0026quot;127.0.0.1\u0026quot;,\r\u0026quot;DATABASE\u0026quot;: \u0026quot;yapi\u0026quot;,\t//这里是刚才创建的mongo数据库\r\u0026quot;port\u0026quot;: 27017,\r\u0026quot;user\u0026quot;: \u0026quot;yapi\u0026quot;,\t//这里是刚才创建的用户\r\u0026quot;pass\u0026quot;: \u0026quot;123456\u0026quot;,\r\u0026quot;authSource\u0026quot;: \u0026quot;\u0026quot;\r}\r最后就是运行Yapi了\n$ cd ~/yapi\r$ npm start\r\u0026gt; yapi-vendor@1.8.6 start /home/liang/projects/git/yapi\r\u0026gt; node server/app.js\rlog: -------------------------------------swaggerSyncUtils constructor-----------------------------------------------\rlog: 服务已启动，请打开下面链接访问: http://127.0.0.1:3000/\rlog: mongodb load success...\rPS：不知道是不是我哪里弄得不对，在yapi的目录直接运行npm start会找不到config.json配置文件，因为提示config.json文件的路径在\u0026quot;../../config.json\u0026quot;，这个位置是相对\u0026quot;server/app.js\u0026quot;来说的，也就是yapi目录的上级目录，这个地方我不是很理解，所以我直接把文件里声明的路径改了。\n//文件路径是 ~/yapi/server/yapi.js\rconst config = require('../../config.json'); //这里改成 ../config.json\r这样Yapi目录中的config.json就可以正常生效了，log日志目录也可以采用类似的方式处理。\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/yapi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","tags":["工具"],"title":"Yapi的安装和使用"},{"content":"一般在使用sqlite的时候都是配置url为绝对路径，但是今天在测试代码的时候想到如果将 项目不到tomcat上之后，db文件总不能一直配置成绝对路径，肯定是项目中的某个位置， 因此对jdbc配置文件进行了修改：\njdbc.url=jdbc:sqlite:blog.db\rdb文件放在WEB-INF/classes下，运行后发现貌似没有问题，然而事实并不是这样QAQ\n因为测试中初始化代码会自动根据bean创建表格，我想是不是生成了一个新的db文件呢， 然后我把初始化关掉之后，果然报错了。。。。。。ORZ，然后我在tomcat的bin目录中 找到了崭新的db文件。\n百般尝试之后依旧如此，于是去看源码，然后在org.sqlite.core.CoreConnection中发现了这么一段：\nprivate static final String RESOURCE_NAME_PREFIX = \u0026quot;:resource:\u0026quot;;\rprivate void open(int openModeFlags, int busyTimeout) throws SQLException {\r// check the path to the file exists\rif (!\u0026quot;:memory:\u0026quot;.equals(fileName) \u0026amp;\u0026amp; !fileName.startsWith(\u0026quot;file:\u0026quot;) \u0026amp;\u0026amp; !fileName.contains(\u0026quot;mode=memory\u0026quot;)) {\rif (fileName.startsWith(RESOURCE_NAME_PREFIX)) {\rString resourceName = fileName.substring(RESOURCE_NAME_PREFIX.length());\r// search the class path\rClassLoader contextCL = Thread.currentThread().getContextClassLoader();\rURL resourceAddr = contextCL.getResource(resourceName);\rif (resourceAddr == null) {\rtry {\rresourceAddr = new URL(resourceName);\r}\rcatch (MalformedURLException e) {\rthrow new SQLException(String.format(\u0026quot;resource %s not found: %s\u0026quot;, resourceName, e));\r}\r}\rtry {\rfileName = extractResource(resourceAddr).getAbsolutePath();\r}\rcatch (IOException e) {\rthrow new SQLException(String.format(\u0026quot;failed to load %s: %s\u0026quot;, resourceName, e));\r}\r}\relse {\rFile file = new File(fileName).getAbsoluteFile();\rFile parent = file.getParentFile();\rif (parent != null \u0026amp;\u0026amp; !parent.exists()) {\rfor (File up = parent; up != null \u0026amp;\u0026amp; !up.exists();) {\rparent = up;\rup = up.getParentFile();\r}\rthrow new SQLException(\u0026quot;path to '\u0026quot; + fileName + \u0026quot;': '\u0026quot; + parent + \u0026quot;' does not exist\u0026quot;);\r}\r// check write access if file does not exist\rtry {\rif (!file.exists() \u0026amp;\u0026amp; file.createNewFile())\rfile.delete();\r}\rcatch (Exception e) {\rthrow new SQLException(\u0026quot;opening db: '\u0026quot; + fileName + \u0026quot;': \u0026quot; + e.getMessage());\r}\rfileName = file.getAbsolutePath();\r}\r}\r// load the native DB\rtry {\rNativeDB.load();\rdb = new NativeDB();\r}\rcatch (Exception e) {\rSQLException err = new SQLException(\u0026quot;Error opening connection\u0026quot;);\rerr.initCause(e);\rthrow err;\r}\rdb.open((SQLiteConnection)this, fileName, openModeFlags);\rsetBusyTimeout(busyTimeout);\r}\r这段代码的大概意思就是在非内存模式且url中开头不是以file：开头的情况下，先判断了url是否是以 :resource:开头，如果是，就以类加载路径进行寻找（获取类加载路径的绝对路径后加载数据库文件）， 否则就直接以url路径为绝对路径加载数据库文件\n于是对jdbc配置文件进行修改：\njdbc.url=jdbc:sqlite::resource:blog.db\r搞定！！！\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AEsqlite%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","tags":["“java\"","jdbc"],"title":"配置sqlite的相对路径"},{"content":"使用Spacemacs国内镜像 最近开始使用emacs写一些clojure的代码，但是不挂梯子的话，源的更新确实不快，因此决定到网上搜索一下怎么配置国内镜像，不过搜索结果大概都是下面这个样子：\n# 基于emacs26\rcd ~\rgit clone https://github.com/syl20bnr/spacemacs .emacs.d\r修改\rvim .emacs.d/core/templates/.spacemacs.template\r(defun dotspacemacs/user-init ()\r\u0026quot;Initialization function for user code.\rIt is called immediately after `dotspacemacs/init', before layer configuration\rexecutes.\rThis function is mostly useful for variables that need to be set\rbefore packages are loaded. If you are unsure, you should try in setting them in\r`dotspacemacs/user-config' first.\u0026quot;\r(setq configuration-layer--elpa-archives\r'((\u0026quot;melpa-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/\u0026quot;)\r(\u0026quot;org-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/org/\u0026quot;)\r(\u0026quot;gnu-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/\u0026quot;)))\r)\r其实也没什么问题，原文内也都说明了是在第一次初始化之前修改这个模板文件。\n不过对于已经配置过的，还是直接修改按照模板生成的配置文件 ~/.spacemacs 即可：\n;; 修改的位置基本不变，修改 ~/.spacemacs 文件\r(defun dotspacemacs/user-init ()\r\u0026quot;Initialization function for user code.\rIt is called immediately after `dotspacemacs/init', before layer configuration\rexecutes.\rThis function is mostly useful for variables that need to be set\rbefore packages are loaded. If you are unsure, you should try in setting them in\r`dotspacemacs/user-config' first.\u0026quot;\r(setq configuration-layer--elpa-archives\r'((\u0026quot;melpa-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/melpa/\u0026quot;)\r(\u0026quot;org-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/org/\u0026quot;)\r(\u0026quot;gnu-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/gnu/\u0026quot;)))\r)\r补充说一句 我看的blog里面很多提到了运行 emacs -nw 可以提升打开速度，但是这个是在linux前提下，是以no window模式打开的，windows里面不要用这个参数，无法打开应用窗口，而且会让系统变得莫名卡顿（win10下亲测）！\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/spacemacs%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/","tags":["emacs"],"title":"Spacemacs配置国内镜像"},{"content":" 十年磨一剑，霜刃未曾试\n——贾岛\n亮剑 少侠们刚从师门中出来，准备闯荡江湖时，难免被前辈指导：”少侠，亮剑吧！“\n此时，少侠们之间的差别就显现出来了。有的在师门勤奋磨剑，精于技艺。有的就是做做样子，整日浑浑噩噩，过着自以为快乐的生活，好吧，其实快乐也挺重要的。\n我们回到前面亮剑的问题，作为一名剑客，在被挑战的时候，拿不出手就很羞耻了，当然，大部分初出茅庐的少侠都是拿不出手或者剑磨得并不怎么样的吧。\n当然，对于大多数人来说，闯江湖的路，一开始都是这个样子。\n转折 有的人呢，受挫之后幡然醒悟，而有的人则走上了逐渐堕落的过程，走向堕落的，他的江湖之旅可能也就止步于此，成绩寥寥，这里就不去赘述了。主要说说那些开始向好的方向发展的少侠们，他们有的进步神速，技艺提升的很快，剑呢也磨得锃光瓦亮，有的就相对进展缓慢，默默无闻。\n少侠们多数都是追求的”十步杀一人，千里不留行“的感觉吧，可是”十年磨一剑“才是稳步提升的正确方式，然而真正做到”十年磨一剑“的，真的还是很少，有的人磨剑、练剑，后来发现他不适合，然后转去练刀、练枪了，也有不少人因而成了大侠。\n练剑 闯荡江湖其实就是修行的过程，但不同的人走的道路还是不一样的。有的人走的是“他山之石，可以攻玉“的路子，博览群书，遍观各路秘籍，最后融会贯通，修成了极高的境界；有的人呢，走的是“一法通，万法通”的路子，精研一道，最后臻至化境，同样修成了正果。归根结底，修行到最后所有的招式都是次要的，最后要达到的终极目标都是“手中无剑，心中也无剑”这种至高的境界。\n当然，有些人年纪轻轻就登堂入室了，而有些，可能终其一生也是不知门在何处，惜哉！\n后记 这篇小文写的断断续续的，中间思路也很乱，写到“练剑”一节终于还是写不下去了。工作五年以来虽然自己的技艺得到了不小的提升，但是经过市场的一番检验之后，终究还是没有达到预期的目标(lll￢ω￢) ，内心之中多多少少还是有一些遗憾的。\n总结了一下自己的问题：\n一是思考问题还是比较浅薄，没有深入去思考，没有多问一个为什么，现在看来，这一点是尤为重要的，想要路走的更远，还是要多去深入的思考，做到知其然更知其所以然； 其次呢，造成这一结果的原因可能还是因为中途掺杂了不少管理上的工作（虽然也包含我在这一方面考虑转型而做出的一些尝试），导致精力分散了不少，目前更是出现了小半年没有什么代码输出的情况 （苦笑，这一点也是我应当付出的代价，毕竟尝试总要付出代价的，不管成功，还是失败。 最后呢，我还是选择了技术这一条路。或许这条路并不是那么容易，但是我还是选择继续走下去，愿所有跟我一样选择这一道路的“剑客”们都能一路披荆斩棘，修成正果。\n不禁想起一句话：\n​\t愿你出走半生，归来仍是少年\n​\t—— 孙衍\n","date":"2019-10-30","permalink":"https://leejoker.github.io/post/%E5%B0%91%E4%BE%A0%E4%B8%8E%E5%89%91/","tags":["杂文"],"title":"少侠与剑"},{"content":"JS整型的坑 昨天同事跟我说js在整型长度支持上有坑，我去查了一下确实是有些坑的。js对于数值的保存遵循IEEE 754 双精度浮点格式规范，采用了双精度存储，占用64bit。如图所示：\n0到51位为尾数（也就是有效数）\n52位到62位为指数。\n如果使用无符号整数格式，则算术中使用的指数值是偏移的指数 - 对于IEEE 754 binary64情况，指数值1023表示实际零（即2 e - 1023为1， e必须是1023）。指数范围从-1022到+1023，因为-1023（全0）和+1024（全1）的指数是为特殊数字保留的。\n最后一位为符号位，用来声明数值的符号，即正负。\n那么可以发现，想保证结果无偏移的话只有e为1023，即有效数为 $$ 2*2^{52} = 2^{53} $$ 即js中长整型不超过\n\u0026gt; Math.pow(2,53)\r\u0026lt;· 9007199254740992\r精度就不会丢失。坑啊(╯‵□′)╯︵┻━┻\nSpringboot中的处理 说一说我的处理方案吧，因为项目使用的fastjson，因此在网上看到的关于jackson的处理方式，诸如@JsonSerialize注解等方式都是不行的，使用SerializeFilter的话改动又太大，最后还是决定自己动手修改返回值类型吧。下面直接上代码：\npackage packagename.response;\rimport org.springframework.core.MethodParameter;\rimport org.springframework.http.MediaType;\rimport org.springframework.http.server.ServerHttpRequest;\rimport org.springframework.http.server.ServerHttpResponse;\rimport org.springframework.web.bind.annotation.RestControllerAdvice;\rimport org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;\rimport java.util.HashMap;\r@RestControllerAdvice\rpublic class ResponseHandler implements ResponseBodyAdvice {\r@Override\rpublic boolean supports(MethodParameter returnType, Class converterType) {\r//默认不进行拦截,返回值为false，拦截则返回true\rreturn true;\r}\r@Override\rpublic Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {\r//对body进行处理\rif (body instanceof HashMap) {\rHashMap\u0026lt;String, Object\u0026gt; finalJson = (HashMap\u0026lt;String, Object\u0026gt;) body;\rfinalJson.forEach((key, value) -\u0026gt; {\rif (value instanceof Long) {\rfinalJson.put(key, String.valueOf(value));\r}\r});\r}\rreturn body;\r}\r}\r如代码所示，body就是返回值内容，对body的处理就是遍历里面的value，将类型为Long的value转化为字符串再塞回去。OK，just it is.\n结语 这个是这两天踩得一个小坑，重点其实不是处理部分，反而是了解了双精度的规范XD，里面关于数据偏移那部分的内容看得也是一知半解，如果内容中包含什么错误，也请路过的小伙伴给予指正，多谢~\n","date":"2019-09-05","permalink":"https://leejoker.github.io/post/js%E6%95%B4%E5%9E%8B%E7%9A%84%E5%9D%91/","tags":["java","javascript"],"title":"Js整型的坑"},{"content":"前言 最近的一个项目里面需要使用gradle打一个可执行的jar包，在网上看了一堆帖子照着做最后都不是很成功，最后终于参考StackOverflow上的帖子搞定了可执行jar包的打包脚本，因此做一个笔记对这个进行一下记录。\n这里是本文的正片 我的代码因为包含了groovy的代码，因此在脚本中包含了groovy的部分配置，如果不适用groovy请去掉相关内容。\nbuildscript {\rrepositories {\rmaven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }\r}\rdependencies {\rclasspath \u0026quot;com.github.jengelman.gradle.plugins:shadow:5.1.0\u0026quot;\r}\r}\rplugins {\rid 'java'\rid 'groovy'\rid 'application'\rid 'com.github.johnrengelman.shadow' version '5.1.0'\r}\rapply plugin: 'com.github.johnrengelman.shadow'\rapply plugin: 'java'\rapply plugin: 'groovy'\rapply plugin: 'application'\rgroup 'groupId of your project' //项目的groupid\rversion '0.0.1'\rmainClassName = \u0026quot;your mainClassName\u0026quot; //项目main方法所在的类名，需要包含完整的包路径\rsourceCompatibility = 1.8\rrepositories {\rmavenCentral()\r}\r//设置编译字符集\rtasks.withType(JavaCompile) {\roptions.encoding = \u0026quot;UTF-8\u0026quot;\r}\rsourceSets {\rmain {\rgroovy {\rsrcDir 'src/main/groovy' // 指定groovy源码目录\r}\rjava {\rsrcDir 'src/main/java' // 指定java源码目录\r}\rresources {\rsrcDir 'src/main/resources' //资源目录\r}\r}\r}\r//这里添加你的依赖\rdependencies {\rcompile fileTree(dir: 'libs', include: ['*.jar'])\rcompile files('your class files path')\rtestCompile group: 'junit', name: 'junit', version: '4.12'\r//集成groovy\rcompile 'org.codehaus.groovy:groovy-all:2.5.8'\r//集成fastjson\rcompile group: 'com.alibaba', name: 'fastjson', version: '1.2.59'\r}\r//使用shadow进行打包\rshadowJar {\rbaseName = 'baseName'\rclassifier = null\rversion = \u0026quot;0.0.1\u0026quot;\rmanifest {\rattributes \u0026quot;Main-Class\u0026quot;: mainClassName\r}\rconfigurations = [project.configurations.runtime] //配置包中包含的依赖的jar包\r}\r然后使用shadowjar打包即可。\n","date":"2019-08-26","permalink":"https://leejoker.github.io/post/%E4%BD%BF%E7%94%A8gradle%E6%89%93%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85/","tags":["gradle","java"],"title":"使用gradle打可执行jar包"},{"content":"前言 事件的起因源自一次客户现场的调试，调试到一半，客户说办公系统突然登录不进去了Σ(っ °Д °;)っ，当时因为手头上的事还没有搞定，就顺手把客户的tomcat重启了，然后似乎就一切正常，我也没有太放在心上。然鹅，事情并没有这么简单。\n麻烦接踵而至 之后的几周里，几乎每隔两周服务就会异常一次，时间非常稳定，问题的表现也很简单，就是登录之后无法完成跳转，一直表现为加载中的状态，直到访问超时。处理方式也很简单粗暴，只要重启tomcat就好了(￣﹏￣；)，其实第一次的时候如果深究一下原因或许就能很快定位了，然而，现在就很麻烦了，因为客户的系统是内部系统，不与互联网连接，每次又急着用不能保留“死亡现场”，就只能通过日志进行判定。\n那就看日志吧 问题是！catalina.out日志里面没有任何登录相关的异常~(╯‵□′)╯︵┻━┻，出现的异常内容也和登录的问题无关。这就说明，至少与登录代码本身是没有什么关系的，那么原因是什么呢？我们做一下简单的分析：\n硬盘空间满：这个是个很坑的问题，在运行中好像也不会产生什么明显的症状，但是一旦硬盘满了，日志无法正常写入，IO就会被阻塞了，然后整个tomcat就不好了，应用的运行自然会受到影响。 请求处理异常：就是在浏览器提交请求后，服务端抛出了异常导致请求没有正常被返回。 数据库服务异常：这个其实和上一点差不多，不过主要问题出在服务器上，上一点造成异常的原因会很多，当然，对于大部分问题来说可能都是NullPointerException（手动滑稽）。 在排除了第一点和第二点之后，问题就主要集中在第三点上，但是数据库本身是正常的，那肯定就是数据库连接出现了问题，问题应该就在c3p0连接池上了。连接池连接数被耗尽，导致登陆时无法正常获取数据库连接，进而无法正常响应请求。\n寻找证据 首先自然是寻找catalina.out日志啦，在里面确实发现了蛛丝马迹，虽然不是登录代码中抛出的数据库无法获取连接的异常，但是确实同一时间段内其他业务类里面抛出的问题。其次，我又手动添加了线程日志的获取以便进一步的取证，创建getlog.sh：\n#!/bin/bash\rpid=`ps aux | grep java | grep -v grep | awk '{print $1}'`\rjstack $pid \u0026gt;\u0026gt; logs/thread_log.`date +%Y%m%d`\r在crontab中添加定时任务：\ncrontab -e\r*/5 * * * * SCRIPTPATH/getlog.sh\r根据后续的日志分析来说，确实是在获取数据库连接那里阻塞了。（原谅我没有截图，弄不出来╮(╯▽╰)╭）\n处理和原因 处理方式很简单，修改一下c3p0连接池的参数就好了\n\u0026lt;!-- 超过时间限制是否回收 --\u0026gt;\r\u0026lt;property name=\u0026quot;removeAbandoned\u0026quot; value=\u0026quot;true\u0026quot;\u0026gt;\r\u0026lt;!-- 超时时限 --\u0026gt;\r\u0026lt;property name=\u0026quot;removeAbandonedTimeout\u0026quot; value=\u0026quot;60\u0026quot;\u0026gt;\r只修改了这个就ok了，因为原来连接数分配的是相对充足的，只是连接一直没有得到正确的释放。这就要继续追问了，为啥没有正确释放呢？\n一般情况下，使用sessionFactory.openSession()的话，会因为session过多且没有关闭导致连接数溢出，但是我的代码里使用的是sessionFactory.getCurrentSession()，session不会被多次创建。\n最后发现是后来添加的定时任务报错了，最开始c3p0连接池设置的超时回收时间长达3小时！你没有看错，3小时！然后这个定时任务就把连接数逐渐蚕食掉了，而且很稳定的2周挂一次。\n总之，这是一个悲伤的故事，请大家引以为戒，如果能够给大家带来帮助，那就是最好的了。\n完结，撒花，★,°:.☆(￣▽￣)/$:.°★ 。\n","date":"2019-05-28","permalink":"https://leejoker.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E5%81%87%E6%AD%BB%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/","tags":["linux","java"],"title":"记一次登录假死的异常排查"},{"content":"从开发到实施XD 因为公司一个小项目要求有负载和热备，于是翻了很多网上的教程，于是找到了这一篇blog,很感谢博客的作者MassiveStars，这篇博客也使我学到了不少关于nginx配置的知识，毕竟以前连nginx都没有碰过XD。本博客大部分内容可能和作者的博客内容雷同，毕竟只是作为笔记存在的东西，侵删。\n配置虚拟IP 互为主从模式 互为主从模式需要配置两个vip（虚拟ip）进行负载，因此是需要负载均衡支持的哟~\n主从模式 即一个服务器为主（master），一个服务器为从（slave），在使用的时候，如果主异常则切换到从服务器，若主服务器恢复，则切回主服务器\nPS：这种模式的弊端就是，当由从向主切换的时候，如果从服务器正在执行操作，可能会产生错误~\n配置方法 ifconfig eth0:0 192.168.40.151 netmask 255.255.255.0 up\neth0: 用ifconfig命令查到的正在使用的网络设备名称，虚拟ip的命名必须采用此规则，建立在某一网络设备下\n配置nginx 安装nginx PS:我用的是ubuntu和opensuse，centos应该类似，建议上网把包down下来编译安装，这样更靠谱一些，当然，用yum安装也没有问题，方法类似\n#安装nginx\rleejoker@ubuntu:~$ sudo apt-get install nginx\r配置nginx服务 #接下来是配置nginx\rleejoker@ubuntu:~$ sudo vim /etc/nginx/nginx.conf\r#PS:这里说明一下，不同的发行版，默认配置可能不同，我是现将默认配置进行了备份，然后重新写了一份，贴上自己的当前配置\r#user nobody;\rworker_processes 1;\r#error_log logs/error.log;\r#error_log logs/error.log notice;\r#error_log logs/error.log info;\r#pid logs/nginx.pid;\revents {\rworker_connections 1024;\r}\rhttp {\rinclude mime.types;\rdefault_type application/octet-stream;\r#log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; '\r# '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; '\r# '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;';\r#access_log logs/access.log main;\rsendfile on;\r#tcp_nopush on;\r#keepalive_timeout 0;\rkeepalive_timeout 65;\r#gzip on;\rserver {\rlisten 8080; #本地端口\rserver_name 192.168.40.151; #本地域名\rlocation / { #代理配置\rproxy_pass http://192.168.17.71:7003;\rproxy_redirect off;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r}\r#charset koi8-r;\r#access_log logs/host.access.log main;\r#error_page 404 /404.html;\r# redirect server error pages to the static page /50x.html\r#\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot html;\r}\r# proxy the PHP scripts to Apache listening on 127.0.0.1:80\r#\r#location ~ \\.php$ {\r# proxy_pass http://127.0.0.1;\r#}\r# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\r#\r#location ~ \\.php$ {\r# root html;\r# fastcgi_pass 127.0.0.1:9000;\r# fastcgi_index index.php;\r# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;\r# include fastcgi_params;\r#}\r# deny access to .htaccess files, if Apache's document root\r# concurs with nginx's one\r#\r#location ~ /\\.ht {\r# deny all;\r#}\r}\r# another virtual host using mix of IP-, name-, and port-based configuration\r#\r#server {\r# listen 8000;\r# listen somename:8080;\r# server_name somename alias another.alias;\r# location / {\r# root html;\r# index index.html index.htm;\r# }\r#}\r# HTTPS server\r#\r#server {\r# listen 443 ssl;\r# server_name localhost;\r# ssl_certificate cert.pem;\r# ssl_certificate_key cert.key;\r# ssl_session_cache shared:SSL:1m;\r# ssl_session_timeout 5m;\r# ssl_ciphers HIGH:!aNULL:!MD5;\r# ssl_prefer_server_ciphers on;\r# location / {\r# root html;\r# index index.html index.htm;\r# }\r#}\r}\r基本上这样就配置完了，本地域名（一般为dns可以解析的域名，自己测试的时候使用的ip）。\n启动nginx #启动nginx\rleejoker@ubuntu:~$ sudo nginx\r配置keepalived 安装keepalived #安装keepalived\rleejoker@ubuntu:~$ sudo apt-get install keepalived\r配置keepalived 先来个图\r这是第一台机器的配置 创建配置文件：sudo vim /etc/keepalived/keepalived.conf\nglobal_defs\r{\rnotification_email\r{\r1056650571@qq.com\r}\rnotification_email_from 1056650571@qq.com\rsmtp_server 127.0.0.1\rstmp_connect_timeout 30\rrouter_id LVS_DEVEL\r}\rvrrp_script Monitor_Nginx {\rscript \u0026quot;/usr/local/keepalived/scripts/monitor_nginx.sh\u0026quot;\rinterval 2\rweight 2\r}\r# 虚拟IP1, 本机作为Master\rvrrp_instance VI_1 {\rstate MASTER\rinterface ens33 #这里就是图上的那个，你的配置文件中用到的网络设备全部写这个\rvirtual_router_id 151\rpriority 100\radvert_int 1\rtrack_interface {\rens33\r}\rauthentication { #这个是两个keepalived之间通信的凭证\rauth_type PASS\rauth_pass 123456\r}\rvirtual_ipaddress {\r192.168.40.151 #这里填写本机配置的虚拟ip\r}\rtrack_script {\rMonitor_Nginx\r}\r}\r# 虚拟IP2, 本机作为Backup\rvrrp_instance VI_2 {\rstate BACKUP\rinterface ens33 #这里是本机作为backup时用到的网络设备\rvirtual_router_id 152\rpriority 100\radvert_int 1\rtrack_interface {\rens33\r}\rauthentication {\rauth_type PASS\rauth_pass 123456\r}\rvirtual_ipaddress {\r192.168.40.152 #这里是本机作为backup时的虚拟ip\r}\rtrack_script {\rMonitor_Nginx\r}\r}\r第二台的配置 global_defs\r{\rnotification_email\r{\r123456@qq.com\r}\rnotification_email_from 123456@qq.com\rsmtp_server 127.0.0.1\rstmp_connect_timeout 30\rrouter_id LVS_DEVEL\r}\rvrrp_script Monitor_Nginx {\rscript \u0026quot;/usr/local/keepalived/scripts/monitor_nginx.sh\u0026quot;\rinterval 2\rweight 2\r}\r# 虚拟IP1, 本机作为BACKUP\rvrrp_instance VI_1 {\rstate BACKUP\rinterface eth0\rvirtual_router_id 151\rpriority 100\radvert_int 1\rtrack_interface {\reth0\r}\rauthentication {\rauth_type PASS\rauth_pass 123456\r}\rvirtual_ipaddress {\r192.168.40.151\r}\rtrack_script {\rMonitor_Nginx\r}\r}\r# 虚拟IP2, 本机作为Master\rvrrp_instance VI_2 {\rstate MASTER\rinterface eth0\rvirtual_router_id 152\rpriority 100\radvert_int 1\rtrack_interface {\reth0\r}\rauthentication {\rauth_type PASS\rauth_pass 123456\r}\rvirtual_ipaddress {\r192.168.40.152\r}\rtrack_script {\rMonitor_Nginx\r}\r}\r配置的内容类似，只不过网络设备上有些差异，就不多说了。\n启动keepalived sudo /usr/sbin/keepalived -f /etc/keepalived/keepalived.conf\rPS:声明一下，关于keepalived的日志网上大多都是说在/var/log/messages下，不过我今天使用的发行版，日志都是和系统日志混在一起的，所以查阅日志的话请自行百度。\nPS:补上我的日志文件路径：/var/log/syslog (ubuntu) 和 jounalctl (opensuse)\n最后补上nginx监控脚本 # 监控nginx进程，若nginx主进程不存在则启动nginx\r# 若5s后nginx进程还是不存在的话kill掉keepalived进程,防止nginx没运行该主机的keepalived还接管虚拟IP\r#!/bin/bash\rif [ \u0026quot;$(ps -ef | grep \u0026quot;nginx: master process\u0026quot;| grep -v grep )\u0026quot; == \u0026quot;\u0026quot; ]\rthen\r/usr/sbin/nginx # 路径请以实际安装路径为准\rsleep 5\rif [ \u0026quot;$(ps -ef | grep \u0026quot;nginx: master process\u0026quot;| grep -v grep )\u0026quot; == \u0026quot;\u0026quot; ]\rthen\rkillall keepalived\rfi\rfi\r总结 按照上面这样配置基本上就完成了互为主从模式的配置，单纯主从模式只是去掉其中的一部分配置，具体可以百度进行参考，就不在这里赘述了。\n","date":"2019-05-21","permalink":"https://leejoker.github.io/post/nginx-keepalived%E9%85%8D%E7%BD%AE%E7%83%AD%E5%A4%87%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/","tags":["linux","部署设计"],"title":"Nginx+keepalived配置热备（互为主从）"},{"content":"线性表 线性表是一个存储相同类型数据元素的有限序列。\n这里面需要关注的两个点就是，相同类型的数据、有限序列。\n线性表包含两种类型：\n顺序表。使用一段地址连续的存储单元依次存储线性表的数据元素。 链表。使用一组任意的存储单元存放线性表的元素。 顺序表 顺序表的特性 顺序表使用的一段连续的存储空间，因此只要知道存储顺序表的起始地址，就可以计算表中任意位置元素的地址。所以，计算任意一个元素的存储地址的时间是相等的 由于上述特性，顺序表具有随机存取的特性。 顺序表存取操作的时间复杂度为O(1)。 顺序表的实现 下面就是一个简单的顺序表的实现：\npublic class SeqList {\r//长度\rprivate int length = 0;\r//数据存储\rprivate Object[] datas;\r//声明线性表最大长度\rprivate final int MAXSIZE = 100;\rpublic SeqList(Object[] datas, int len) throws Exception {\rif (len \u0026gt; MAXSIZE) {\rthrow new Exception(\u0026quot;初始化失败，长度超过允许的最大值\u0026quot;);\r}\r//这里使用最大长度去初始化线性表\rthis.datas = new Object[MAXSIZE];\rfor (int i = 0; i \u0026lt; len; i++) {\rthis.datas[i] = datas[i];\rthis.length = len;\r}\r}\r//获取坐标为i的元素\rpublic Object get(int i) throws Exception {\rif (i \u0026lt; 0 || i \u0026gt; length - 1) {\rthrow new Exception(\u0026quot;查找位置错误\u0026quot;);\r} else {\rreturn this.datas[i];\r}\r}\r//根据值获取index\rpublic int getIndex(Object data) {\rfor (int i = 0; i \u0026lt; length; i++) {\rif (data.equals(datas[i])) {\rreturn i;\r}\r}\rreturn -1;\r}\r//插入操作\rpublic void insert(Object data, int index) throws Exception {\rif (index \u0026lt; 0 || index \u0026gt; length) {\rthrow new Exception(\u0026quot;插入位置错误\u0026quot;);\r} else if (index \u0026gt;= MAXSIZE) {\rthrow new Exception(\u0026quot;上溢\u0026quot;);\r} else {\rfor (int i = length - 1; i \u0026gt; index; i--) {\rdatas[i + 1] = datas[i];\r}\rdatas[index] = data;\rlength++;\r}\r}\r//删除操作\rpublic void delete(int index) throws Exception {\rif (index \u0026lt; 0 || index \u0026gt; length) {\rthrow new Exception(\u0026quot;删除位置错误\u0026quot;);\r} else if (length == 0) {\rthrow new Exception(\u0026quot;下溢\u0026quot;);\r} else {\rSystem.out.println(\u0026quot;删除的元素为：\u0026quot; + datas[index].toString());\rfor (int i = index; i \u0026lt; length; i++) {\rdatas[i] = datas[i + 1];\r}\rlength--;\r}\r}\r//判空\rpublic boolean isEmpty() {\rif (length == 0) {\rreturn true;\r} else {\rreturn false;\r}\r}\r//遍历\rpublic void printList() {\rfor (int i = 0; i \u0026lt; length; i++) {\rSystem.out.println(datas[i]);\r}\r}\rpublic int getLength() {\rreturn length;\r}\r}\r我们知道，Java中ArrayList类就是一个顺序表，其实现的基本原理也和上述代码差不多，但是ArrayList是包含一个自动增长的机制的，下面我们就简单分析一下这个自增长机制。\nArrayList的自增长 首先说一下ArrayList的初始化：\nprivate static final int DEFAULT_CAPACITY = 10;\rprivate static final Object[] EMPTY_ELEMENTDATA = {};\rprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\rtransient Object[] elementData; // non-private to simplify nested class access\rpublic ArrayList(int initialCapacity) {\rif (initialCapacity \u0026gt; 0) {\rthis.elementData = new Object[initialCapacity];\r} else if (initialCapacity == 0) {\rthis.elementData = EMPTY_ELEMENTDATA;\r} else {\rthrow new IllegalArgumentException(\u0026quot;Illegal Capacity: \u0026quot;+\rinitialCapacity);\r}\r}\rpublic ArrayList() {\rthis.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\r}\rpublic ArrayList(Collection\u0026lt;? extends E\u0026gt; c) {\relementData = c.toArray();\rif ((size = elementData.length) != 0) {\r// c.toArray might (incorrectly) not return Object[] (see 6260652)\rif (elementData.getClass() != Object[].class)\relementData = Arrays.copyOf(elementData, size, Object[].class);\r} else {\r// replace with empty array.\rthis.elementData = EMPTY_ELEMENTDATA;\r}\r}\r从构造函数可以看出，默认生成的是一个空的数组，默认的容量是10。\npublic boolean add(E e) {\rensureCapacityInternal(size + 1); //新增一个元素时，根据当前长度扩容\relementData[size++] = e;\rreturn true;\r}\rprivate void ensureCapacityInternal(int minCapacity) {\rif (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\rminCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //当前数组为空时，根据传入的长度和默认容量确认应该采用哪个值进行容量需求的确认\r}\rensureExplicitCapacity(minCapacity);\r}\rprivate void ensureExplicitCapacity(int minCapacity) {\rmodCount++;\rif (minCapacity - elementData.length \u0026gt; 0) //当容量需求大于当前长度时（这个是存储的数组的长度，而非实际存储内容的size），执行增长\rgrow(minCapacity);\r}\rprivate void grow(int minCapacity) {\r// overflow-conscious code\rint oldCapacity = elementData.length;\rint newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //增长策略为 newCapacity = oldCapacity+(oldCapacity/2)\rif (newCapacity - minCapacity \u0026lt; 0)\rnewCapacity = minCapacity; //如果增长后仍不满足需求，则使用实际需求容量\rif (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0)\rnewCapacity = hugeCapacity(minCapacity);\r// minCapacity is usually close to size, so this is a win:\relementData = Arrays.copyOf(elementData, newCapacity);\r}\r以上就是ArrayList的自动增长的策略了，简单点来说就是先判断当前容量是否满足插入，如果不满足，执行扩容（扩容策略为 新容量=原容量 + （原容量/2）），如果仍不满足，就是用当前需要的容量值作为扩容结果。（没有考虑超过MAX_ARRAY_SIZE的情况）\n结语 线性表先写到这里吧，后面一篇就是把链表的部分补完，如果有什么问题，请路过的大佬予以补充~如果有人提问请在下方评论区提问，么么哒~\n","date":"2019-02-05","permalink":"https://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/","tags":["算法","数据结构","Java"],"title":"数据结构与算法学习系列(二)"},{"content":"这个系列还会继续的 忽然发现我之前已经建立了这篇博客，心想姑且把这篇完成吧，后续更高级的内容等我琢磨明白了再放出来。这个系列并不是一个单纯学习教程，更是我对Clojure认知的一种体现吧，说实话从java这种语言跳到clojure上还是有挺多问题的，至少思维方式可能就需要进行蛮大的转变，后续估计还会在读一些SICP之类的内容去逐渐加深自己对于LISP这个深坑的理解。\n说一说常用的东西 这一节就来说一说常用的一些函数，在实际的应用中不论是刷题还是实际的开发应用，都会经常的用到，比如递归 map reduce apply 等等，这些都是接触clojure之后都会经常看到，用到的方法。那么，今天就来说说这些吧。\n递归 递归的话在一般的语言中（没错，我说的就是Java），一般都会采用这种方式：\npublic int doMethod(int param){\r// do something\rdoMethod(param);\r}\r在方法内部调用方法本身实现递归，完成方法的递归调用。\n然而，在clojure中这种方式虽然可以，但却会造成堆栈的溢出（因为Clojure的尾递归优化不是用的原函数名,而是使用的recur，使用原函数名会不断产生新的实例从而造成堆栈溢出）。\n(defn recur-fibo [n]\r(letfn [(fib\r[current next n]\r(if (zero? n)\rcurrent\r;recur将递归调用fib函数\r(recur next (+ current next) (dec n))))]\r(fib 0 1 n)))\r上面这个例子摘自Clojure的recur尾递归优化探秘。文章主要表达的意思是，在方法实现方法实例后，每次刷新存储的参数，然后通过invoke调用方法实例实现尾递归优化。感兴趣的同学可以去仔细读一读庄晓丹大佬对于recur的解读，更为深入。\nmap reduce apply map reduce apply都是遍历执行的方法，不过map、reduce和apply的返回值不太一样。\nmap map返回的是一个lazy sequence,根据map的文档描述中可以知道，map是遍历所有传入参数，然后将每个参数执行传入函数的结果作为随后lazy-seq的元素。\n(map #(+ 1 %) (range 10))\r;; user=\u0026gt; (map #(+ 1 %) (range 10))\r;; (1 2 3 4 5 6 7 8 9 10)\rapply apply的参数有两部分，一个是执行的函数，另一部分是执行函数的参数。\napply会依次传入参数并执行函数。\n(apply + 1 [2 3 4 5])\r(apply + [1 2 3 4 5])\r;; user=\u0026gt; (apply + 1 [2 3 4 5])\r;; 15\r;; user=\u0026gt; (apply + [1 2 3 4 5])\r;; 15\r但是要注意，apply传入的参数必须能够是一个列表，否则会造成类型识别失败。\nuser=\u0026gt; (apply + 1 2 3 4 5)\rIllegalArgumentException Don't know how to create ISeq from: java.lang.Long clojure.lang.RT.seqFrom (RT.java:542)\rreduce reduce和apply类似，但是reduce中传入的函数中，函数的参数必须是两个。\n(reduce + [1 2 3 4 5]) ;;=\u0026gt; 15\r(reduce + []) ;;=\u0026gt; 0\r(reduce + [1]) ;;=\u0026gt; 1\r(reduce + [1 2]) ;;=\u0026gt; 3\r(reduce + 1 []) ;;=\u0026gt; 1\r(reduce + 1 [2 3]) ;;=\u0026gt; 6\r(def x {:a 1 :b 2})\r(reduce (fn [p [k v]]\r(into p {k (+ 1 v)}))\r{}\rx)\r;;=\u0026gt; {:a 2, :b 3}\r结语 其实还有很多遍历的方法，比如在递归中用的很多的loop。还有for这个和java中的关键字长得很像的函数。但是由于我掌握的其实也很有限，在这一篇里就不再进行具体讲述了。在后续的章节里，我会逐渐加深内容的深度。这一篇就姑且到这里吧o(￣▽￣)ブ\n","date":"2019-02-04","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E5%9B%9B/","tags":["clojure","学习笔记"],"title":"clojure读书笔记其四"},{"content":"关于新坑和旧坑的说明 我又开了一个新的坑，迫于近期一些方面的压力，我又把数据结构和算法这个东西捡起来了，至于之前Clojure学习笔记系列的坑，咳咳，虽然还会更新下去，但是估计会延后很多了，因为学了Clojure蛮久的时间了，没有太多的实践机会，也没有对Clojure理解的足够深，因此这个系列估计会稍微放一放，等我理解足够深刻了在继续下去（对不起，还是因为懒XD）。\n什么是算法 算法，这个东西其实是思路的体现，也可以说是问题的解决方案。相信大家也都看到过这句话：\n程序=算法+数据结构\n虽然这么说或许不够准确，但是算法对于程序本身而言意义是十分重大的。也是影响程序性能的一个关键因素。大多时候算法都是一个由实际问题转化而成的数学模型，因此，像写出一个好的算法的话首先要能充分理解问题，然后就是将问题转化成一个高效的数学模型。所以说啊，学好数学还是很关键滴~\n什么是数据结构 数据结构是承载数据的（逻辑结构+存储结构）的总和，逻辑结构体现了数据元素之间的逻辑关系和元素自身的逻辑特性，而存储结构则是数据元素在存储设备上的存在形式。同时，存储结构也是逻辑结构在物理设备上的体现，存储的方式在一定程度上体现了数据元素之间的逻辑关系。\n一些概念的笔记 这部分算是一些基本概念的笔记，考试专用哦XD，虽然没什么太大的用处，但是也体现了数据结构和算法的一些根本原则，对于初学者而言还是有必要了解一下。\n算法是对特定问题求解步骤的一种描述，是指令的有限序列 算法的五个重要特性：输入、输出、确定性、有穷性、可行性 “好”算法的五个特性：正确性、健壮性、可理解性、抽象分级、高效性 算法的描述方法：自然语言、流程图、程序设计语言、伪代码 时间复杂度和空间复杂度 这里简单地解释一下其中可能有迷惑的一些概念。\n确定性：简单来说就是算法在不改变参数的前提下，其结果是确定的，不会变化的。相同的输入一定带来相同的输出。 有穷性：算法一定是可以结束的，这里指的是实际应用场景下而非算法结果本身（比如我的算法是产生一个无限的素数队列，但是我实际只需要截取前几位或固定位数，那么对于我而言算法就是有穷的）。 抽象分级：简单来说就是对算法不同部分的划分，哪一部分的算法是用来做什么的，其结果又用于哪个部分中作为参数。算法是一个相对整体的概念，但是中间的过程需要做出分割以便其他人能够理解和修改。 流程图和伪代码：这个意思我就不解释了，但是流程图和伪代码应该多去学习和理解，尤其是流程图，在工作之后很多时候是个很好的工具，而伪代码则是在忽略语法细节时最好的代码表现形式（其实就是忘了这里咋写了，然后大概写一下，滑稽XD）。 时间复杂度和空间复杂度：现在是一个硬件过剩的时代，空间复杂度往往是被大家忽略的一点，很多时候甚至会拿空间换时间，所以说时间复杂度的优化往往是性能提升的重头戏。但是！空间复杂度在整体设计上其实是很关键的一环，优秀的设计能大大缓解存储资源吃紧，提升程序效率（扩容啊啥的设计的烂的话太要命了）。还有，时间复杂度的分析要好好学哦，这里就不多说了，但是考试会考到~ 几种算法的设计思路 蛮力法：采用一定策略依次处理求解问题的所有数据，即遍历数据集的方式，通常性能较低，用于处理较为基本的问题。 分治法：将问题分解为更小的规模然后各个击破，最后合并所有子模式的结果。如二叉树的遍历，深度优先遍历，快速排序等。 减治法：将问题分解为更小规模的问题，只需要解决其中一个小规模问题即可获得结果，无需合并所有子模式的结果。如插入排序，拓扑排序。 贪心法：将问题分解为一系列简单局部最优选择，每一步选择都是对当前解的扩展。如哈夫曼算法，Prim算法等。 动态规划法：将问题分解成若干子问题，但是子问题间并非相互独立，根据子问题间的关系动态规划函数。如FLOYD算法。 本篇结语 这一篇只是一篇引子，你可以当我又水了一篇文章，哈哈~不过，对于初学算法和数据结构的人而言，最初的认识往往是最重要的，对知识有一个完整的认识非常重要，可以让人更为明确所学的东西是什么，有什么，包含哪些内容，学习的目标或者最终达成的效果是什么，我要不要学etc. 这些其实都能从一个整体的概述中获取到。平时读书也是一样，先读一下序，看看作者或者其他人对于书的整体内容的认知是什么样的，可以迅速帮你确认这是不是你想看的内容。\n后续内容说明 如果大佬看到篇文章可以尽情吐槽我，因为确实菜啊，毕业后好多知识都还给老师了，还是从最基础的开始学习。也是帮助刚开始进行学习这些的孩纸，我会把学校的教材从头到尾捋一遍，当然会根据不同的内容进行整理哒~也希望能帮助到看到这篇文章的萌新们XD\n","date":"2019-02-03","permalink":"https://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/","tags":["算法","数据结构","Java"],"title":"数据结构与算法学习系列（一）"},{"content":"lein与私有仓库 lein在new一个新的项目的时候都会从maven或者clojars上下载对应的依赖，但是一旦你离开了互联网环境只有一个maven私服的时候，这一切就变得不是那么美好了。因此，我们需要配置一下lein，让它能够从我们指定的位置下载依赖。\n创建profiles.clj 在$HOME/.lein/下创建profiles.clj文件，在其中添加如下内容：\n{\r:user {\r:mirrors {\r\u0026quot;central\u0026quot; {\r:name \u0026quot;nexus-maven\u0026quot;\r:url \u0026quot;https://ip:port/repository/maven-central/\u0026quot;\r}\r\u0026quot;clojars\u0026quot; {\r:name \u0026quot;nexus-clojure\u0026quot;\r:url \u0026quot;https://ip:port/repository/clojars/\u0026quot;\r}\r}\r:certificates [\u0026quot;path of nexus.pem\u0026quot;]\r}\r}\rclojure默认是不允许使用http的仓库，因此必须使用https的链接，并在certificates里配置相应的证书，这样lein在加载依赖的时候就可以自动通过设置的maven仓库下载依赖了。\n配置nexus使用https 根据官方文档中说明，需要进行如下步骤：\n在$install-dir/etc/ssl/下创建keystore文件keystore.jks\n在$data-dir/etc/nexus.properties文件中添加 application-port-ssl=8443\n在$data-dir/etc/nexus.properties文件nexus-args属性中添加${jetty.etc}/jetty-https.xml，如下所示：\nnexus-args=${jetty.etc}/jetty.xml,${jetty.etc}/jetty-http.xml, \\ ${jetty.etc}/jetty-https.xml,${jetty.etc}/jetty-requestlog.xml\r在$install-dir/etc/jetty/jetty-https.xml中配置keystore文件的密码，如果你没有设置keystore的密码这一步就可以忽略\n到这一步位置其实nexus的https就已经配置好了，但是lein的certificates的证书貌似需要使用pem文件，因此需要自己转换成pem文件并放在自己指定的路径下就可以了。\nkeystore文件生成和转换 官方文档中其实包含证书生成的内容，我这里就进行简单的copy了 XD。\n生成证书库和证书： keytool -genkeypair -keystore example.jks -storepass password -alias \\ example.com -keyalg RSA -keysize 2048 -validity 5000 -keypass password \\ -dname 'CN=*.example.com, OU=Sonatype, O=Sonatype, L=Unspecified, \\ ST=Unspecified, C=US' -ext \\ 'SAN=DNS:nexus.example.com,DNS:clm.example.com,DNS:repo.example.com, \\ DNS:'www.example.com'\r转换为PKCS12证书： keytool -importkeystore -srckeystore example.jks -destkeystore example.p12 -deststoretype PKCS12\r将PKCS12证书转换为openssl证书： openssl pkcs12 -nokeys -in example.p12 -out example.pem\r通过以上步骤就完成了pem证书的生成，然后在profiles.clj中certificates属性里进行配置就可以了。\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\n","date":"2018-11-01","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AElein%E7%9A%84%E7%A7%81%E6%9C%89%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93/","tags":["clojure","lein","nexus"],"title":"配置lein的私有依赖仓库"},{"content":"Namespace 名称空间对于Clojure来说是一个逻辑上对于代码进行分组的概念，类似于Java的package，通过使用名称空间能够规避方法名冲突，有效的对代码进行管理。主要应用的话，其实就是方便代码的引入和使用了，毕竟你不可能将所有代码放到一个clj文件中。\ncreate-ns user\u0026gt; (create-ns 'clojure.by.example)\rnil\r这样一个名称空间就建立好了，是不是so easy！\nin-ns ;; create the namespace and switch to it\r(in-ns 'first-namespace)\rin-ns的主要作用是切换到指定的namespace中，如果这个namespace不存在，则会创建他。\nrequire/refer/use 这三个要放在一起来说，因为他们的作用都是引入一个namespace，但是使用细节上略有不同。\nrequire require的作用最为纯粹，就是单纯的引入一个namespace。\n;; 最简单的使用\ruser\u0026gt; (require 'clojure.by.example)\rnil\r;; 当然你也可以起个别名\ruser\u0026gt; (require '[clojure.by.example :as cbe])\rnil\r;; 当然你还可以引入多个\ruser\u0026gt; (require '[clojure.by.example :as cbe]\r'[clojure.core :as cc])\rnil\r引入namespace后，你就可以调用namespace中的方法了。\nuser\u0026gt; (cbe/your_function_name)\rrefer/use refer的作用是绑定一个namespace到当前namespace，这样你就可以直接使用函数名来调用函数，而不需要前面的namespace了。\nuser\u0026gt; (refer 'clojure.by.example)\rnil\ruser\u0026gt; (your_function_name)\rrefer的使用存在一定问题，就是后引入的namespace中如果方法名与当前namespace或之前引入的namespace中存在冲突，会自动覆盖这些冲突，而且你无法在引入之后重新定义这些函数，会抛出异常。\n;; 就是下面类似的这种异常\rCompilerException java.lang.IllegalStateException: join already refers to: #'clojure.string/join in namespace: user, compiling:(null:1:1)\rrefer还可以单独引入namespace中的特定方法。\n;; 引入的namespace中的方法为了避免冲突是可以进行重命名的\ruser=\u0026gt; (refer 'clojure.string\r:rename '{capitalize cap, trim trm})\r;; only可以单独引入namespace中的指定方法，但是方法名必须是原名，而不能是经过rename之后的名字\ruser\u0026gt; (refer ‘clojure.string :only ‘[capitalize trim]) ;; 这样写就会抛出异常\ruser=\u0026gt; (refer 'clojure.string\r:rename '{capitalize cap, trim trm}\r:only '[cap trm])\rIllegalAccessError cap does not exist clojure.core/refer (core.clj:3849)\r而use就是将require和refer合二为一的函数，这里就不再赘述了。\nimport import是clojure中专门用来引入java包的函数。\nuser=\u0026gt; (import java.util.Date)\rjava.util.Date\ruser=\u0026gt; (new Date)\r#inst \u0026quot;2018-01-21T09:49:55.468-00:00\u0026quot;\rns ns方法感觉是引入namespace中相对常用的函数。\n(ns example.namespace\r(:require [clojure.java.io])\r(:use [clojure.data])\r(:import [java.util List Set]))\r","date":"2018-01-21","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%B8%89/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其三"},{"content":"配置国内插件源 atom这个编辑器确实很好用，但是她的插件安装的速度实在是让人难受，没有梯子的话会让人抓狂w(ﾟДﾟ)w，在网上查了一下，找到了一个比较靠谱的方案，记下来方便以后使用。\n本方法在linux和windows下都是可用的 在**$HOME/.atom目录下新建.atomrc**文件 在文件内添加如下内容： registry=https://registry.npm.taobao.org/ strict-ssl=false\rOver !\n","date":"2018-01-15","permalink":"https://leejoker.github.io/post/atom%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90/","tags":["atom","配置"],"title":"Atom配置国内源"},{"content":"今天的主题是Function 正如标题所言，今天这篇笔记的主题是function，当然也就是lisp语言中的一等公民，\u0026ldquo;函数\u0026quot;啦XD\n那么直入主题，首先来看一下怎么定义一个函数： ;; name params body\r;; ----- ------ -------------------\r(defn greet [name] (str \u0026quot;Hello, \u0026quot; name) )\r这里我引用了官方文档中的说明。\n那么这个函数的使用就可以像上一篇中所说的那样：\nuser=\u0026gt; (greet \u0026quot;小明\u0026quot;)\r\u0026quot;Hello, 小明\u0026quot;\r你也可以给你的方法增加方法说明： (defn greet \u0026quot;this is the greet function for you\u0026quot;\r[name] (str \u0026quot;Hello, \u0026quot; name))\r文档说明可以用doc函数去查看: (doc greet)\r;;----------------------------------\ruser/greet\r([name])\rthis is the greet function for you\r函数是支持定义多种参数列表的 (defn messenger\r([] (messenger \u0026quot;Hello world!\u0026quot;))\r([msg] (println msg)))\r当传入不同的参数的时候，会根据参数列表执行不同的函数体。\n但执行的方法没有匹配的参数列表时：\n(messenger \u0026quot;aaa\u0026quot; \u0026quot;bbbb\u0026quot;)\rArityException Wrong number of args (2) passed to: user/messenger clojure.lang.AFn.throwArity (AFn.java:429)\r那么怎么实现上面这种不定参数的问题呢，那就需要用到 \u0026amp; 符号：\n(defn messenger [greeting \u0026amp; who]\r(println greeting who))\r(messenger \u0026quot;aaa\u0026quot; \u0026quot;bbbb\u0026quot; \u0026quot;cccc\u0026quot; \u0026quot;dddd\u0026quot;)\r;;------------------------------------------------------\raaa (bbbb cccc dddd)\r或许和你的预期不同，clojuer将\u0026amp;符号后面的参数认为是一个列表，因此在打印的时候是按照列表打印的，而没有与第一个参数作为同一个列表。\n匿名函数 匿名函数有两种写法：\n;; 写法一\r((fn [x] (println \u0026quot;Hello, \u0026quot; x)) \u0026quot;Leejoker!\u0026quot;)\rHello, Leejoker!\ruser=\u0026gt;\rnil\r;;------------------------------------------------------\r;; 写法二\r(#(println \u0026quot;Hello, \u0026quot; %) \u0026quot;Leejoker!\u0026quot;)\rHello, Leejoker!\ruser=\u0026gt;\rnil\r那让我们看一下这两种写法的组成吧：\n;; anonymous params body\r;; -------- ------ -------------------\r(fn [name] (str \u0026quot;Hello, \u0026quot; name) )\r;; anonymous body params\r;; -------- ------------ ------- #( (str \u0026quot;Hello, \u0026quot; %1 %2 %\u0026amp;))\r;; 同样，匿名函数里也可以用 \u0026amp; 来定义不定参数列表\r当然，你也可以把匿名函数绑定一个函数名：\n(def greet (fn [x] (println \u0026quot;Hello, \u0026quot; x)))\r;; 或者是这样\r(def greet #(println \u0026quot;Hello, \u0026quot; %))\r;;-------------------------------------------------------\r(greet \u0026quot;lala\u0026quot;)\rHello, lala\ruser=\u0026gt;\rnil\r好用的apply apply可以使一个函数依次调用一个列表中的参数：\n(defn plot [a b]\r(apply + a b))\r(plot 1 '(2 3 4 5))\r;;----------------------------------------\ruser=\u0026gt;\r15\rclosure clojure的总用看官方文档说应该是用来突破参数作用范围的，这里理解的可能不是很透彻，也希望有大大能够指正，下面是从官方文档中拿来的例子：\n(defn messenger-builder [greeting]\r(fn [who] (println greeting who))) ; closes over greeting\r;; greeting provided here, then goes out of scope\r(def hello-er (messenger-builder \u0026quot;Hello\u0026quot;))\r;; greeting value still available because hello-er is a closure\r(hello-er \u0026quot;world!\u0026quot;)\r;; Hello world!\rjava function 最后一部分就是java方法的调用了：\n(defn getlen [obj] (.length obj))\r;;--------------------------------------------\r(getlen \u0026quot;123\u0026quot;)\ruser=\u0026gt;\r3\r下面是官方文档给出的调用方式：\nTask JAVA Clojure 实例化 Object obj = new Object(\u0026ldquo;foo\u0026rdquo;) (def obj (Object. \u0026ldquo;foo\u0026rdquo;)) 实例方法调用 obj.toString() (.toString obj) 实例属性值 obj.field (.-field obj) 静态方法 Math.sqrt(25) (Math/sqrt 25) 静态属性 Math.PI Math/PI 官方文档中习题 Define a function greet that takes not arguments and prints \u0026ldquo;Hello\u0026rdquo;. Replace the _ with the implementation: (defn greet [] _)\r;;---------------------------------\r(defn greet [] (println \u0026quot;Hello\u0026quot;))\rRedefine greet using def, first with the fn special form and then with the #() reader macro. ;; using fn\r(def greet __)\r;; using #()\r(def greet __)\r;;------------------------------------------------\r(def greet (fn [] (println \u0026quot;Hello\u0026quot;)))\r(def greet #(println \u0026quot;Hello\u0026quot;))\rDefine a function greeting which: Given no arguments, returns \u0026ldquo;Hello, World!\u0026rdquo; Given one argument x, returns \u0026ldquo;Hello, x!\u0026rdquo; Given two arguments x and y, returns \u0026ldquo;x, y!\u0026rdquo; ;; Hint use the str function to concatenate strings\r(doc str)\r(defn greeting ___)\r;; For testing\r(assert (= \u0026quot;Hello, World!\u0026quot; (greeting)))\r(assert (= \u0026quot;Hello, Clojure!\u0026quot; (greeting \u0026quot;Clojure\u0026quot;)))\r(assert (= \u0026quot;Good morning, Clojure!\u0026quot; (greeting \u0026quot;Good morning\u0026quot; \u0026quot;Clojure\u0026quot;)))\r;;-----------------------------------------------------------\r(defn greeting\r([] (str \u0026quot;Hello, World!\u0026quot;))\r([param] (str \u0026quot;Hello, \u0026quot; param \u0026quot;!\u0026quot;))\r([param1 param2] (str param1 \u0026quot;, \u0026quot; param2 \u0026quot;!\u0026quot;)))\rDefine a function do-nothing which takes a single argument x and returns it, unchanged. (defn do-nothing [x] ___)\r;;--------------------------------\r(defn do-nothing [x] x)\rDefine a function always-thing which takes any number of arguments, ignores all of them, and returns the keyword :thing. (defn always-thing [__] ___)\r;;---------------------------------\r(defn always-thing [\u0026amp; args] :thing)\r;; ps:\r;; \u0026amp; 符号后面必须有空格才能识别\r;; \u0026amp;args 这样写无效\rDefine a function make-thingy which takes a single argument x. It should return another function, which takes any number of arguments and always returns x. (defn make-thingy [x] ___)\r;; Tests\r(let [n (rand-int Integer/MAX_VALUE)\rf (make-thingy n)]\r(assert (= n (f)))\r(assert (= n (f :foo)))\r(assert (= n (apply f :foo (range)))))\r;;---------------------------------------------------------\r(defn make-thingy [x] (fn [\u0026amp; args] x))\rDefine a function triplicate which takes another function and calls it three times, without any arguments. (defn triplicate [f] ___)\r;;----------------------------------\r(defn triplicate [f] (f) (f) (f))\r;;PS:\r;; 在网上查了一下，问题的翻译是定义一个函数，参数是另一个函数，并在函数体\r;; 中调用3次，大概是这么个意思，刚开始看了好长时间都没明白过来要我做什么，汗\rDefine a function opposite which takes a single argument f. It should return another function which takes any number of arguments, applies f on them, and then calls not on the result. The not function in Clojure does logical negation. (defn opposite [f]\r(fn [\u0026amp; args] ___))\r;;-----------------------------\r(defn opposite [f]\r(fn [\u0026amp; args] (not (apply f args))))\rDefine a function triplicate2 which takes another function and any number of arguments, then calls that function three times on those arguments. Re-use the function you defined in the earlier triplicate exercise. (defn triplicate2 [f \u0026amp; args]\r(triplicate ___))\r;;--------------------------------\r(defn triplicate2 [f \u0026amp; args]\r(triplicate (fn [] (apply f args))))\rUsing the java.lang.Math class (Math/pow, Math/cos, Math/sin, Math/PI), demonstrate the following mathematical facts: The cosine of pi is -1 For some x, sin(x)^2 + cos(x)^2 = 1 (= 1.0 (+ (Math/pow (Math/sin Math/PI) 2) (Math/pow (Math/cos Math/PI) 2)))\r(= -1.0 (Math/cos Math/PI))\rDefine a function that takes an HTTP URL as a string, fetches that URL from the web, and returns the content as a string. ; Hint: Using the java.net.URL class and its openStream method.\r; Then use the Clojure slurp function to get the content as a string.\r(defn http-get [url] ___)\r(assert (.contains (http-get \u0026quot;http://www.w3.org\u0026quot;) \u0026quot;html\u0026quot;))\r;;-----------------------------------------------------------\r(defn http-get [url]\r(slurp (.openStream (java.net.URL. url))))\rDefine a function one-less-arg that takes two arguments: * f, a function * x, a value and returns another function which calls f on x plus any additional arguments. (defn one-less-arg [f x]\r(fn [\u0026amp; args] ___))\r;;-----------------------------\r(defn one-less-arg [f x]\r(fn [\u0026amp; args] (apply f x args)))\rDefine a function two-fns which takes two functions as arguments, f and g. It returns another function which takes one argument, calls g on it, then calls f on the result, and returns that. (defn two-fns [f g]\r___)\r;;----------------------------\r(defn two-fns [f g]\r(fn [x] (f (g x))))\r","date":"2018-01-07","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%BA%8C/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其二"},{"content":"简述 学习clojure的起因主要还是想学习lisp语言吧。由于既想学lisp现阶段又无法脱离jvm这个大的框架,所以就发现了clojure语言，然后就踏上了“自虐”的不归路:D\n学习思路 在刚开始学习的过程中，我看了很多相关的教程、博客，但总是感觉不得其门而入，简单来说就是找不到这门语言的学习思路。大体是因为clojure和传统的C type语言思路不同吧，再加上语法糖太多，导致各种磕磕碰碰。仔细想想，还是整理一下目前所学，也希望整理的东西能给clojure的初学者提供一定的帮助。\n本系列的笔记是基于官方文档整理、补充的，如有错漏，请在评论区指出，以便及时进行修改，也有助于我自身的提升和进步。\n语言学习的第一步 没错，就是Hello World！\nuser=\u0026gt; (println \u0026quot;Hello, Clojure!\u0026quot;)\rHello, Clojure!\rnil\r这一句是在repl中执行的，哦，差点忘了，记得安装lein哦，至于怎么装请自行百度，如果需要梯子，emmmmm，自己想办法吧，程序员或者想成为程序员的人不应该被一面墙阻拦（有人敲门，我去开一下，Σ(っ °Д °;)っ好像有哪里不对）\n言归正传，输出的结果是“Hello, Clojure!”，但方法的返回值是nil，这个输出其实就是函数println的副产物。\n对于clojure的整体认知 下面这一段是我从官方文档中截取的类型说明。\n;; 数字类型\r42 ; Long - 64-bit integer (from -2^63 to 2^63-1)\r6.022e23 ; Double - double-precision 64-bit floating point\r42N ; BigInt - arbitrary precision integer\r1.0M ; BigDecimal - arbitrary precision fixed-point decimal\r22/7 ; Ratio\r;; 字符类型\r\u0026quot;hello\u0026quot; ; String\r\\e ; Character\r;; 其他类型\rnil ; null value\rtrue ; Boolean (also, false)\r#\u0026quot;[0-9]+\u0026quot; ; Regular expression\r:alpha ; Keyword\r:release/alpha ; Keyword with namespace\rmap ; Symbol\r+ ; Symbol - most punctuation allowed\rclojure.core/+ ; Namespaced symbol\r;; 集合\r'(1 2 3) ; list\r[1 2 3] ; vector\r#{1 2 3} ; set\r{:a 1, :b 2} ; map\rclojure所有的语句都是包含括号的，当然像集合那几个声明方式可以除外（集合那几种同样也是有普通的函数声明方式的）。\n括号内的第一个值是函数体，剩下的值都是这个函数的参数。\n这是clojure最基本的一个概念，也是最重要的一个概念，“函数是一等公民”\n同样，当你想这样使用的时候，他会给你一个错误。\nuser=\u0026gt; (1 2 3)\rClassCastException java.lang.Long cannot be cast to clojure.lang.IFn\r所以你需要使用quote去让clojure知道你不想把它解读成一个函数。\nuser=\u0026gt; (quote (1 2 3))\r(1 2 3)\r;; 操作同 '(1 2 3)\ruser=\u0026gt; '(1 2 3)\r(1 2 3)\r不过，这样一等公民就变成quote了，哈哈哈哈\n说一下变量 说一下变量的一些概念吧，不然第一篇就这么草草的结束，肯定有人要说我没有干货了XD\n变量的定义主要包含两种，一个是def，另一个是let\ndef类似于全局变量，可以被重新赋值\nlet则相当于局部变量，下面给出了一些例子（感谢clojure-by-example项目提供的例子）。\ndef的使用： user=\u0026gt; (def object \u0026quot;light\u0026quot;)\r#'user/object\ruser=\u0026gt; (println (str \u0026quot;God said let there be \u0026quot; object))\rGod said let there be light\rnil\ruser=\u0026gt; (def object \u0026quot;darkness\u0026quot;)\r#'user/object\ruser=\u0026gt; (println (str \u0026quot;God said let there be \u0026quot; object))\rGod said let there be darkness\rnil\rlet的使用 user\u0026gt; (let [a \u0026quot;aaa\u0026quot;]\r(println a))\raaa\rnil\ruser\u0026gt; (let [a \u0026quot;aaa\u0026quot;]\r(let [a \u0026quot;AAA\u0026quot;]\r(println a)))\rAAA\rnil\ruser\u0026gt; (let [a \u0026quot;aaa\u0026quot;]\r(let [a \u0026quot;AAA\u0026quot;]\r(println a))\r(println a))\rAAA\raaa\rnil\ruser\u0026gt; (let [a \u0026quot;a\u0026quot;]\r(let []\r(println a)))\ra\rnil\ruser=\u0026gt; (let [l \u0026quot;light\u0026quot;\rd \u0026quot;darkness\u0026quot;]\r(println (str \u0026quot;God said let there be \u0026quot; l))\r(println (str \u0026quot;God also said let there be \u0026quot; d)))\rGod said let there be light\rGod also said let there be darkness\rnil\ruser\u0026gt; (let [l \u0026quot;light\u0026quot;\rl_d (str l \u0026quot; and\u0026quot; \u0026quot; darkness\u0026quot;)]\r(println (str \u0026quot;God also said let there be \u0026quot; l_d)))\rGod also said let there be light and darkness\rnil\r第一篇就这样吧 第一篇姑且就到这里吧，学习这种函数式语言其实最重要的是对于这种语言有一个正确的认知，然后才是各种语法和应用，如果你始终带着面向对象那种思路反而不太利于clojure的学习。 嘛~ 各位我们下一篇再见！\n","date":"2018-01-06","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%B8%80/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其一"},{"content":"从disqus到gitment 其实就易用性和使用效果上讲，disqus还是很好用的，只需要注册一个账号，在主题里配置一下就可以了，然而，disqus最大的问题还是在于翻墙，咳，科学上网。今天这个问题我的一个小伙伴也跟我吐槽了，毕竟不是每个人都会去弄个vpn啊，ss啊之类的东西。因此，回家之后果断搞起。\n接下来就是正片了 注册OAuth Application [点此注册] [1]\n填写示例如下图所示：\n填写的重点主要在“Authorization callback URL”，这里应该填你的blog的域名（比如我的就是https://leejoker.github.io）\n注册好之后会获得一个client id和client secret，这个就是用来配置gitment评论与你 GitHub账户关联的信息 。（这个没记住也不要紧，之后也可以在github的settings/Developer settings中找到滴XD） [1]: https://github.com/settings/applications/new \u0026ldquo;注册OAuth Application\u0026rdquo;\n在主题中配置gitment 我使用的是jacman主题，网上配置gitment的教程大多都是next主题的，因此，特地折腾了一番才配好。当然，使用next主题的同学请自行百度/谷歌教程。\n创建用来存储评论的repo 在GitHub上创建一个repo用来存储评论信息，记得勾上初始化（一开始没勾，结果怎么都不能初始化评论，我真傻，真的QAQ）\n修改jacman评论的布局文件 jacman评论的布局文件在“themes\\jacman\\layout_partial\\post”目录下，打开comment.ejs,将以下代码覆盖原有代码（没错，就是覆盖）。\n\u0026lt;section id=\u0026quot;comments\u0026quot; class=\u0026quot;comment\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;blog_comment\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://imsun.github.io/gitment/style/default.css\u0026quot;\u0026gt;\r\u0026lt;script src=\u0026quot;https://imsun.github.io/gitment/dist/gitment.browser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rvar gitment = new Gitment({\rowner: '你的github用户名',\rrepo: '你用来存储评论信息的repo',\roauth: {\rclient_id: '之前注册生成的client_id',\rclient_secret: '之前注册生成的client_secret',\r},\r})\rgitment.render('blog_comment')\r\u0026lt;/script\u0026gt;\r\u0026lt;/section\u0026gt;\r这里有一点需要注意的就是“blog_comment”这个id，之前[作者的blog] [2]中的代码用的是“container”作为id的，但是jacman这个主题用来包裹整个文本的div的id就是container，因此，必须修改id才行，否则评论就会出现在正文的正上方(╯‵□′)╯︵┻━┻ [2]: https://imsun.net/posts/gitment-introduction/ \u0026ldquo;Gitment：使用 GitHub Issues 搭建评论系统\u0026rdquo;\n初始化评论 将配置好的blog发布到github上之后，打开你的任意一篇文章，在最下面点击初始化评论按钮即可。不过这里很不幸的是，你每一篇blog都要手动初始化一下，很蛋疼，目前还没有找到解决的办法，希望后续能解决这个问题。\n","date":"2017-10-11","permalink":"https://leejoker.github.io/post/%E6%8A%98%E8%85%BEhexo%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9C%A8jacman%E9%87%8C%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","tags":["hexo"],"title":"折腾hexo系列之在jacman里集成gitment评论系统"},{"content":"编程的精义 开发是一个阐述思想的过程，把想法转化成逻辑，最后变成代码，就是整个开发的过程。\n编程，是开发的一环，也就是把逻辑转化为代码的过程。\n正如文中所说的那样，“程序=算法+结构”。算法是顺序，分支，循环的组合变化，结构是思想在程序中的映射。因此，代码在编程里是最为easy的一环。\n嘛~~第一章大致就是说了这么一个内容，强调了在编程过程中最为重要的反而是思想，逻辑。掌握语言和转化成代码其实都是最为容易的事。PS:是不是说我只要懂得足够多就能当PPT架构师了:)\n当然，这里说代码是思想的转化自然是没什么问题的，然而写代码同样是一个磨练技艺的过程，怎么写更好，怎么写更易懂，怎么写更容易维护，这也是一个程序猿需要不断去锻炼学习的。PS：这一段与原文主旨没什么关系，只是忽然想到就加上了。不过话说回来，在这方面如果能做到尽善尽美，这让接盘子的人会非常开心吧(o゜▽゜)o☆\n是懒人造就了方法 “懒人”是相对于“愚公”那种“勤快人”而言的，这里都加上了引号，主要还是因为这里都不是明面上的意思，“懒人”不是真正意义上的懒人，“勤快”也并非是什么好事。\n对于开发而言，一味为了完成而做重复的工作是很可怕的，虽然结果可能没什么问题，但是其中的效率和后续要做的工作可能远高于开发时的工作量。\n停下来，做一个会思考的“懒人”在开发中是很有必要的，抽象，方法的调整，不管是对于开发还是后续的维护，都是有益的\n项目管理那些事 我是学管理出身的（不过是信息管理，O(∩_∩)O~），我的管理学老师曾经跟我们说过，“管理学是对人的研究”，管理学不同于其他研究性的学问，更多的关注与人的分工和人与人之间的关系。而对于一个技术出身的人，去做管理，不仅仅是角色的转变，做事方式、承担的责任都会发生变化。\n作为项目管理者，你就是项目的总负责人，如果项目出了问题，你就是责任的承担着，将锅甩给谁都不好使，因为别人看到的就是如此：你带的团队，你接的活，你的项目失败了！仅此而已。\n但往往失败都是能带来成长的，所谓失败是成功之母，不过并非对于所有人来说失败都是成功他母上的XD，只有能够从中发现问题，汲取经验的人，才能够更进一步。所以，项目失败之后不要总是埋怨这个，埋怨那个，更多的应该反思一下自己哪个环境没弄好，是核心人员选的不对？没有按照计划严格执行？团队沟通做的不好？还是自己没有起到好的带头作用？\n说到沟通，从我的感觉来说（毕竟还没做过大的项目呢，/(ㄒoㄒ)/~~ ），越是大的项目，越有可能发生沟通上的问题。为什么这么说呢，简单点来说，就是人多事杂。不同的模块干活的人可能有好几个，他们之间沟通可能是没问题的，但是不同模块的负责人就不一定了，可能这边一个事完了，就继续搞下一个了，但是依赖有更新，接口有变更，这个没及时提，就会造成一些问题。这个只是一个非常浅显的例子，但是实际开发中类似的事情也并非不会发生（或许会很频繁也说不定XD）。\n后续的巴拉巴拉 在后续的内容里作者讨论了人、组织以及关乎项目成败的种种因素，但看完之后隔了一段时间发现还有印象的内容就只剩下“造轮子”的讨论了（莫非我没有管理人员的命ORZ）。\n对于重复造轮子，可能对于很多开发者或者跟我有相似工作经验的开发者而言（我主要做的是交付项目），造轮子是件很没有意义的事情，只有快速找个轮子把任务完成才是最为关键的。\n然而，用了诸多轮子之后发现，当你遇到问题，你还是不得不去把轮子拆开，看看到底里面是怎么做的，然后一通调整，最后，你会发现你把原理弄明白了，然后自己重新做了一个轮子(lll￢ω￢)。\n所以说，重复造轮子并非毫无意义，当你已经成了一个大神，应对各种问题都胸有成竹，那自然重复造轮子就显得是一种时间上的浪费，这是可耻的。可是大多数人都不是大神，很多东西并没有一个成熟的体系化的解决方案，因此，自己造个轮子不但学了技术，更是对自身实力的一种磨练和提升。\n后记 其实在写最后一段内容的时候，离读完这本书已经过去了很长时间了（大概有一个月吧），很多后续内容也没有去仔细品味琢磨。不过从这本书中还是学到了很多东西，不管是技术上的还是管理上的，虽然书中并没有给出问题的解决方案（这点很遗憾），但却留出了很大的思考空间。总体而言是一本很有深度的书籍，我的水平不够就不进一步评价了，喵o(=•ェ•=)m\n嗯，就这样吧，实在不知道写啥了XD\n","date":"2017-08-16","permalink":"https://leejoker.github.io/post/%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","tags":["读书"],"title":"《大道至简》读书笔记"},{"content":"班车上的感慨（人总是莫名伤感233333） 转眼间已经快工作3年了，年龄也逐渐到达了26岁，我不知道我会在IT这个行业坚持多久，或许是几年也或许是一辈子。人们总是说时光荏苒，白驹过隙。但不仔细回头想想，真的不会发现时间就这样在每天匆忙的上下班中从自己的身后溜走了。 回想过去两年的工作（我是在传统开发行业工作的，互联网接触的不多，主要还是学了没地方用QAQ），虽然在技术上逐渐成熟，也学了很多的东西（想想自己从刚毕业什么都不会，到现在当个开发组的小组长内心还是颇为自豪的23333），框架的，前端的，后端的，也踩了各种坑，但是看看前沿的论坛新闻，感觉自己离这个时代要求的能力还是有不小差距的。不能沉迷于所得的成就，人总是得向前看。 30而立，但看着自己离30岁越来越近，事业上，爱情上都是毫无建树（单身狗。。。哇的一声哭了出来），不禁心里有了些触动，这也是我写这篇博文的动机（估计没什么人愿意看我发牢骚）。\n多多少少还是要学些东西 感觉最近多多少少还是要看一些书的（虽然每年都会看，但从没有像今天这样觉得自己这么弱鸡），书单如下大概会像下面这个样子： 1. spring boot in action(至少了解下现在是怎么部署开发微服务的吧，(～￣▽￣)～）�) 2. 自己动手写java虚拟机（这个主要是用来学jvm） 3. hotspot实战（同上，虽然看了些《深入了解java虚拟机》，但是感觉看的发懵） 4. effective go（go还是继续学，虽然办公环境没有互联网的我内心是崩溃的/(ㄒoㄒ)/~~） 5. 张爱玲的一些文集（没想到我是这样的人吧233333） 6. 未来简史（这本书感觉很有趣，正在看） 虽然感觉列多了，但是技术书会尽量看，当然非技术的我一定会看完（请尽情的鄙视我吧）。\n写着写着莫名心情愉悦了 没心没肺的人果然还是容易获取快乐，居然写着写着就感觉莫名happy了，算了，反正是随笔性质的东西，姑且写到哪算哪吧，反正没人看23333 最后激励一下自己，嗯，Fight ！！！\n","date":"2017-03-17","permalink":"https://leejoker.github.io/post/26%E5%B2%81%E7%9A%84%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90/","tags":["杂文"],"title":"26岁的细思极恐"},{"content":"Ubuntu下添加ppa仓库 此处以安装atom为例，命令如下：\nsudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom 这样就把atom的仓库添加并安装完成了。\n然而，并没有这么简单\nsudo: add-apt-repository : command not found\rmdzz 这是怎么回事，不应该是这样的(╯‵□′)╯︵┻━┻\n解决 百度之后（虽然百度烂但是有些东西还是能查到的），发现还要添加一个python-software-properties包，话说为什么apt仓库要用python的包啊喂(#O′))\n没办法，照办吧，遂执行：\nsudo apt-get install python-software-properties\rsudo add-apt-repository ppa:webupd8team/atom\rsudo: add-apt-repository : command not found\r什么鬼！！！为什么还是不对，看来依赖还是不足，继续百度，发现还需要安装software-properties-common\n抱着试试的心态执行了一下：\nsudo apt-get install software-properties-common\rsudo add-apt-repository ppa:webupd8team/atom\rMore info, report packaging bugs, feedback, etc.: http://www.webupd8.org/2014/05/install-atom-text-editor-in-ubuntu-via-ppa.html\rReport non-packaging Atom bugs here: https://github.com/atom/atom/issues\r更多信息： https://launchpad.net/~webupd8team/+archive/ubuntu/atom\r按回车继续或者 Ctrl+c 取消添加\rgpg: 钥匙环‘/tmp/tmp7nbejmnw/secring.gpg’已建立\rgpg: 钥匙环‘/tmp/tmp7nbejmnw/pubring.gpg’已建立\rgpg: 下载密钥‘EEA14886’，从 hkp 服务器 keyserver.ubuntu.com\rgpg: /tmp/tmp7nbejmnw/trustdb.gpg：建立了信任度数据库\rgpg: 密钥 EEA14886：公钥“Launchpad VLC”已导入\rgpg: 没有找到任何绝对信任的密钥\rgpg: 合计被处理的数量：1\rgpg: 已导入：1 (RSA: 1)\rOK\r执行成功ㄟ(≧◇≦)ㄏ\n结语 虽然感觉这点很坑（话说包管理添加第三方库为什么还要用其他包啊），但是总算圆满解决了问题，可喜可贺，可喜可贺！\n","date":"2016-10-11","permalink":"https://leejoker.github.io/post/ubuntu%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0ppa%E4%BB%93%E5%BA%93/","tags":["linux"],"title":"Ubuntu下如何添加ppa仓库"},{"content":"这一篇主要说明application.go的主要构成和其中用到方法的主要作用。\n参数定义 application.go中定义了初始化时需要用到的常量和变量\n常量定义： const (\rINDEX_CACHE = \u0026quot;index\u0026quot; //各类别下rank\rALL_RANK_CACHE = \u0026quot;all_rank\u0026quot; //总的rank\rBANGUMI_CACHE = \u0026quot;bangumi\u0026quot; //番剧\rBANGUMI_LIST_CACHE = \u0026quot;bangumi_list\u0026quot; //新番放松表\rSORT_TOP_CACHE = \u0026quot;sort-\u0026quot; //具体某个类别rank(这个在index_cache中要用到)\rLIVE_INDEX_CACHE = \u0026quot;live_index\u0026quot; //直播rank\r)\r全局变量定义： var (\rProdLevels = []log.Level{\rlog.InfoLevel,\rlog.NoticeLevel,\rlog.WarnLevel,\rlog.ErrorLevel,\rlog.PanicLevel,\rlog.AlertLevel,\rlog.FatalLevel,\r}\r)\r这里主要定义了release模式下用到的日志级别。(PS:类库引用的是\u0026quot;github.com/go-playground/log\u0026quot;)\n结构体定义 type BiliBiliApplication struct {\rRouter *gin.Engine //路由\rCorn *CornService //初始化服务\rConf *Config //配置信息\rClient *client.BCli //客户端\rCache *CacheManager //缓存管理\r}\r这里定义了Bilibili-go主体程序的结构。\n初始化rank数据并注册任务 application.go中使用了conformTask方法进行了数据的初始化以及任务注册\n//application.go\rconformTask(app)\rcorn.Start()\rconformTask方法如下：\n//application.go\rfunc conformTask(app *BiliBiliApplication) {\rapp.Corn.RegisterTask(\u0026amp;IndexInfoTask{CornTask: CornTask{Name: \u0026quot;index_info\u0026quot;, Duration: 2 * time.Hour}, app: app})\rapp.Corn.RegisterTask(\u0026amp;BangumiInfoTask{CornTask: CornTask{Name: \u0026quot;bangumi_info\u0026quot;, Duration: 6 * time.Hour}, app: app})\rapp.Corn.RegisterTask(\u0026amp;BangumiListTask{CornTask: CornTask{Name: \u0026quot;bangumi_list\u0026quot;, Duration: 6 * time.Hour}, app: app})\rapp.Corn.RegisterTask(\u0026amp;TopRankTask{CornTask: CornTask{Name: \u0026quot;top_rank\u0026quot;, Duration: 2 * time.Hour}, app: app})\rapp.Corn.RegisterTask(\u0026amp;LiveIndexTask{CornTask: CornTask{Name: \u0026quot;alive_index\u0026quot;, Duration: 2 * time.Hour}, app: app})\r}\r从方法名上看是调用了CornService中的RegisterTask(注册任务)的方法，那么，我们看一下这个RegisterTask方法到底做了些什么吧。\n//corn.go\r//execute task\rfunc exec(f CornTaskImpl) {\rlog.Info(\u0026quot;invoke task, taskname: \u0026quot;, f.GetName())\rdefer func() {\rif r := recover(); r != nil {\rlog.Error(r)\r}\r}()\rif err := f.Run(); err != nil {\rf.Failure(err)\r} else {\rf.Success()\r}\rlog.Info(\u0026quot;run task end, taskname: \u0026quot;, f.GetName())\r}\r//这里就是那个名为注册任务的方法\rfunc (c *CornService) RegisterTask(task CornTaskImpl) {\rtask.SyncLastRunTime()\rexec(task)\rc.tasks = append(c.tasks, task)\r}\r不难发现，实际上这个注册任务的方法就是将task执行了一下，然后放到c.tasks数组里。\n而之后的corn.Start()方法：\n//corn.go\rfunc (c *CornService) syncTaskList(nowTime time.Time) {\rfor _, task := range c.tasks { //循环任务列表\r//Unix timestamp =\u0026gt; duration\rbetween := time.Duration(nowTime.Unix()-task.GetLastRun().Unix()) * time.Second\rif between \u0026gt;= task.GetDuration() { //当时间间隔大于设定的时间周期则执行,并修改LastRun的值\rtask.SyncLastRunTime()\rexec(task)\r}\r}\r}\rfunc (c *CornService) loop() {\rfor {\rselect {\rcase \u0026lt;-c.done:\rlog.Info(\u0026quot;corn loop stopped....\u0026quot;)\rreturn\rcase nowTime := \u0026lt;-c.ticker.C: //这里通过计时器获取到当前时间\rgo c.syncTaskList(nowTime)\r}\r}\r}\rfunc (c *CornService) Start() {\rgo c.loop()\r}\rcorn.Start()方法开启了一个loop线程，这个线程简单的来说就是每隔一分钟执行一次syncTaskList方法。\n到此，bilibili-go这个小项目的学习也基本上告一段落了，剩下的内容基本上都是数据获取和处理的部分。这个项目虽然很小，但是对多线程的学习，go的基础都有很大的帮助，在此也感谢WhiteBlue大大，(^_^)\n","date":"2016-09-28","permalink":"https://leejoker.github.io/post/bilibili-go%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","tags":["go","bilibili"],"title":"bilibili-go项目源码学习笔记_2"},{"content":"bilibili-go服务加载流程浅析 main.go中使用了service包中的application.go创建了新的应用，进而开启了bilibili-go服务，并监听了8080端口。代码如下：\npackage main\rimport (\r\u0026quot;github.com/go-playground/log\u0026quot;\r\u0026quot;github.com/whiteblue/bilibili-go/service\u0026quot;\r)\rfunc main() {\rapp, err := service.NewApplication(\u0026quot;conf.json\u0026quot;)\rif err != nil {\rlog.Fatal(err)\r}\rapp.Router.Run(\u0026quot;:8080\u0026quot;)\r}\r在application.go中，使用了gin作为web框架，并依次执行了以下操作：\n首先读取了appkey和secret，\nconf, err := ReadConfigFromFile(configFile)\r设置日志，\ncLog := console.New()\rif conf.Debug {\rlog.RegisterHandler(cLog, log.AllLevels...)\rgin.SetMode(gin.DebugMode)\r} else {\rlog.RegisterHandler(cLog, ProdLevels...)\rgin.SetMode(gin.ReleaseMode)\r}\r加载了gin的中间件，\nr := gin.New()\r//use gzip\rr.Use(gin.Recovery())\rr.Use(gzip.Gzip(gzip.BestCompression))\r启动了CornService用于初始化数据（主要初始化了各类别下的rank数据），\n//corn service\rcorn := NewCornService()\r创建了bilibiliClient，\n//bilibili client\rcli := client.NewClient(conf.Appkey, conf.Secret)\r启动了缓存管理,\ncache := NewCacheManager()\r最后建立app，并执行了初始化操作,\n//建立app应用\rapp := \u0026amp;BiliBiliApplication{Router: r, Corn: corn, Conf: conf, Client: cli, Cache: cache}\r//加载路由\rConformRoute(app)\rlog.Info(\u0026quot;conform route\u0026quot;)\r//进行rank数据初始化\rconformTask(app)\rcorn.Start()\rlog.Info(\u0026quot;conform task\u0026quot;)\rlog.Info(\u0026quot;init complete, start listen...\u0026quot;)\r完整代码如下：\nfunc NewApplication(configFile string) (*BiliBiliApplication, error) {\rconf, err := ReadConfigFromFile(configFile)\rif err != nil {\rreturn nil, err\r}\rcLog := console.New()\rif conf.Debug {\rlog.RegisterHandler(cLog, log.AllLevels...)\rgin.SetMode(gin.DebugMode)\r} else {\rlog.RegisterHandler(cLog, ProdLevels...)\rgin.SetMode(gin.ReleaseMode)\r}\rlog.Info(\u0026quot;conform config file\u0026quot;)\rr := gin.New()\r//use gzip\rr.Use(gin.Recovery())\rr.Use(gzip.Gzip(gzip.BestCompression))\r//corn service\rcorn := NewCornService()\r//bilibili client\rcli := client.NewClient(conf.Appkey, conf.Secret)\rcache := NewCacheManager()\rapp := \u0026amp;BiliBiliApplication{Router: r, Corn: corn, Conf: conf, Client: cli, Cache: cache}\rConformRoute(app)\rlog.Info(\u0026quot;conform route\u0026quot;)\rconformTask(app)\rcorn.Start()\rlog.Info(\u0026quot;conform task\u0026quot;)\rlog.Info(\u0026quot;init complete, start listen...\u0026quot;)\rreturn app, nil\r}\r通过路由和初始化的rank数据，就可以获取相应的列表以及视频信息了。\n","date":"2016-09-27","permalink":"https://leejoker.github.io/post/bilibili-go%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","tags":["go","bilibili"],"title":"bilibili-go项目源码学习笔记_1"},{"content":"为什么要写这个 最近对go语言萌生了不小的学习欲望，因而找了一本书开始看，看到指针一节，不禁再次想起了那些被c语言支配的恐怖日子（这也是我选择java的原因啊，（╯\u0026rsquo; - \u0026lsquo;)╯︵ ┻━┻ ）。不过，经过再次整理之后发现其实指针这个概念还是蛮好理解的，也希望这篇小文章能给那些难以理解指针的童鞋一点帮助（没帮倒忙就好，o(╯□╰)o），下面就来详细说明一番。\n指针概念解析 指针的概念其实主要分为两个部分，一个是内存地址，另一个则是内存地址指向的值。举个栗子：\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r)\rfunc main() {\ra := 3\rb := 5\rfmt.Println(a, b) //输出值：3 5\r}\r对于变量a而言，\u0026amp;a就是内存中变量a的地址。那么我们如何通过内存中的地址获取到值呢，看下面代码：\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r)\rfunc main() {\ra := 3\rc := \u0026amp;a\rfmt.Println(*c) //输出值：3\r}\r我们将a的内存地址\u0026amp;a赋给变量c，通过c就取出了地址\u0026amp;a中的值，因此通过就可以将相应地址的值取出了。\n总结 *和\u0026amp;是一对相对的概念，\u0026amp;代表地址，*代表地址对应的值，因此一个变量\na := 3\r\u0026amp;a代表了变量a内存地址，而a的值就可以写作*\u0026amp;a了。怎么样，是不是很简单（本来就很简单啦，果然还是自己太笨了，╮(╯▽╰)╭）\n","date":"2016-09-21","permalink":"https://leejoker.github.io/post/%E5%AF%B9%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/","tags":["go"],"title":"对于Go语言中指针的思路整理"},{"content":"div旋转﻿ \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\r.hexHead {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\r-webkit-transform: rotate(60deg); \u0026lt;!--这里旋转60度--\u0026gt;\rmargin-left: 48px;\r}\r.hexCenter {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\rmargin-left: 48px;\rmargin-top:-138px;\r}\r.hexBottom {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\r-webkit-transform: rotate(-60deg);\rmargin-left: 48px;\rmargin-top:-138px;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div class=\u0026quot;hexHead\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hexCenter\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hexBottom\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r控制边框 \u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;Draw Hive\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt;\r.hiveTop {\rwidth: 0;\rborder: 30px solid #6C6;\rborder-top: none;\rborder-bottom: 30px solid #6C6;\rborder-left: 52px solid transparent;\rborder-right: 52px solid transparent;\r}\r.hiveCenter {\rwidth: 104px;\rheight: 60px;\rbackground-color: #6C6;\r}\r.hiveBottom {\rwidth: 0;\rborder: 30px solid #6C6;\rborder-bottom: none;\rborder-top: 30px solid #6C6;\rborder-left: 52px solid transparent;\rborder-right: 52px solid transparent;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveTop\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveCenter\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveBottom\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rcss实现 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;六边形\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\r.wrap {\rmargin: 100px;\rwidth: 303px;\r}\r.nav {\rwidth: 100px;\rheight: 58px;\rbackground: #339933;\rdisplay: inline-block;\rposition: relative;\rline-height: 58px;\rtext-align: center;\rcolor: #ffffff;\rfont-size: 14px;\rtext-decoration: none;\rfloat: left;\rmargin-top: 31px;\rmargin-right: 1px;\r}\r.nav s {\rwidth: 0;\rheight: 0;\rdisplay: block;\roverflow: hidden;\rposition: absolute;\rborder-left: 50px dotted transparent;\rborder-right: 50px dotted transparent;\rborder-bottom: 30px solid #339933;\rleft: 0px;\rtop: -30px;\r}\r.nav b {\rwidth: 0;\rheight: 0;\rdisplay: block;\roverflow: hidden;\rposition: absolute;\rborder-left: 50px dotted transparent;\rborder-right: 50px dotted transparent;\rborder-top: 30px solid #339933;\rbottom: -30px;\rleft: 0px;\r}\r.a0 {\rmargin-left: 100px;\r}\r.a1 {\rmargin-left: 50px;\r}\r.nav:hover {\rbackground: #8CBF26;\rcolor: #333333;\r}\r.nav:hover s {\rborder-bottom-color: #8CBF26;\r}\r.nav:hover b {\rborder-top-color: #8CBF26;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;wrap\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;nav a0\u0026quot; target=\u0026quot;_blank\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt;广播\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r图就不展示了，就结果而言，三者都可以产生六边形的按钮，但是显而易见第三种更适合用来做为按钮使用。\n第一种：要用到三个div，需添加多个相同超链接才能够达到覆盖整个六边形的目的 第二种：上下两个div宽度全是0，且也是三个div 第三种：方便易用，但是是用绝对定位处理的，这可能在后期调整上对于像我这种前端苦手而言或许会带来一些苦难QAQ\n","date":"2016-09-21","permalink":"https://leejoker.github.io/post/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%8C%89%E9%92%AE/","tags":["CSS"],"title":"如何创建六边形按钮"}]
=======
[{"content":"篇首语 　好久没写博客了，最近公司的事情搞得我一个头两个大，不禁感慨，PM真的不是人干的活啊（当PM的小伙伴别打我 XD）。\n　算了，闲话少叙，还是说说为啥写减肥吧。\n　说到减肥，其实应该是不少小伙伴们比较关心的话题（当然，如果你不关心这个话题也请关注一下自己的体重，和体重带给自己的外貌、身体状况、求偶等多方面的影响，以及这些影响是正面的？还是负面的？），尤其是在工作以后，别的先不说，小肚子肯定有的。我身边的同事有的也很瘦，但是小肚子真的是一个比一个大。随之而来的，就是脂肪肝等等一堆肥胖带来的并发症。。。\n似乎扯远了，我也不打算说肥胖带来的问题，主要还是讲讲自己减肥的缘由和关于减肥的一些想法。\n缘起 　想要减肥的原因很简单，就是怕死~\n　听起来似乎有点扯，但是确实如此。\n　起因是2017年去深圳出差。那一个月的加班可能让我毕生难忘。每天9点开工，干到凌晨三点，偶尔通宵，持续一月。干到最后阶段的时候，项目终于是脱离了危险，但是感觉人快没了，有的时候不禁怀疑，刚才心脏是不是漏拍了QAQ。除了加班，还有就是饮食问题了，因为那个时候不太节制，再加上我本人相当能吃，所以体重自然噌噌噌的长了上去。回到帝都之后，家人一度怀疑是不是打了激素，不然怎么会催肥催的如此显著 XD。\n　自那之后，我决定，一定要减下去！\n然而过程大多数时候是很艰难且容易放弃的 　正如这一节的标题所言，过程大多数时候都是艰难且容易放弃的。慢跑刚开始我是拒绝的，真的枯燥，所以我选择了跳绳。然而也没坚持多久。随后是Keep和健身环，但是始终强度不够。不过可能是基数够大，也很快减了5公斤左右，然后就因为工作和自身的一些原因，减肥就搁置了。\n　随后是2019年，我2月份和同事办了健身卡，然后控制饮食，一周三到四天健身房，每天20~30分钟撸铁（刚开始必然是很菜的，后面慢慢好了点），40~60分钟慢跑，随后是拉伸。这段时间是给我减肥树立信心的过程，因为真的减下来了，大概2个月的时间，瘦了将近10公斤！不过，之后的疯狂加班直接导致我的减肥破产，而且反弹了回去（熬夜、宵夜这两个真的要不得，加班还不能太控制饮食，饿着肚子加班，根本没法干活），这个结果也直接导致我选择了离职（不过主要原因是加班和钱少XD）。\n　在之后就是今年5月份到现在了，更换了工作之后，明显安逸了不少，然而这也导致我的体重十分稳定，减肥终于再次被我提上了日程。\n　这次我没有选择健身房，没有选择Keep之类的软件，很简单，就是跑步，从500米喘得够呛到5公里能够一次性跑完，这个过程真的是痛苦又充满成就感的，我逐渐喜欢上了跑步，喜欢上了跑完以后浑身酸爽的感觉。\n成果 　目前就成果而言还算显著，已经减下去了10公斤左右（93.7 -\u0026gt; 83.5），而且应该还没有到平台期，通过控制每天摄入的能量和消耗应该还能继续减下去。\n　肌肉的话应该也掉了一些，不过其实这些我都不是很在意，先减下去再说吧，肌肉注意蛋白质的摄入和适当肌肉训练应该不至于掉的太厉害，第一要务还是把体脂减下去。\n一些心得  不要追求速度，不要追求距离，调整好运动的心态是第一要务，只有想去运动，能够保持才是最关键的。 适当的步速：慢跑看中的还是运动的时间，距离什么的不重要，能够有配合呼吸的步速才能坚持下去。 意志力  这个是我前期跑不了太远的问题，一定要坚持哪怕很累的也要完成预定的目标。（当然，目标可以根据每天身体状态调整，但是一定要完成） 第二个方面就是一定要管住嘴，晚上一定杜绝诱惑，如果想吃尽量早吃，且不要太多，根据跑步的距离衡量热量的摄入（这一点务必慎重，不要养成不好的习惯）   减少碳水，杜绝暴饮暴食  放在最后 　扯了这么多，无非是炫耀一下减肥的成果，然后给自己加油打气~（不过也好像没啥可炫耀的，瘦了不少，但是体脂还是挺高）\n　坚持，才可能有所收获，与诸君共勉~\n","date":"2021-08-11","permalink":"https://leejoker.github.io/post/%E5%85%B3%E4%BA%8E%E8%BF%90%E5%8A%A8%E5%87%8F%E8%82%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/","tags":["杂文"],"title":"关于运动减肥的一些经验之谈"},{"content":"首先来吐槽一波(╯‵□′)╯︵┻━┻ 本来呢，我是想加一层feign的interceptor处理feign里request请求的返回信息的，比如只提取ResponseBody中的data啥的。后来想起来feign默认使用的是jdk的HttpURLConnection，而且feign本身是支持替换okhttp的，于是打算搞起~\n可是，百毒到的都是什么鬼啊，按照别人写的文档配好，各种问题，什么springboot注解不行啦，需要使用feign默认注解，什么负载均衡失效啦，无语。(╯‵□′)╯︵┻━┻\n最后，还是自己操刀，从源码看吧。\n遂有此文~\n百毒，淦！\n首先来写一个简单的interceptor 不需要这个的跳过看下一段吧~\n//这个interceptor的目的是提取返回body中的data，并转化为json\r@Component\rpublic class OkHttpResponseInterceptor implements Interceptor {\r@Override\rpublic Response intercept(Chain chain) throws IOException {\rRequest request = chain.request();\rResponse response = chain.proceed(request);\rif (HttpHeaders.hasBody(response)) {\rif (response.code() == 200) {\rResponseBody responseBody = response.body();\rif (responseBody != null\r\u0026amp;\u0026amp; responseBody.contentLength() != 0\r\u0026amp;\u0026amp; Objects.requireNonNull(responseBody.contentType()).type()\r.equals(MediaType.APPLICATION_JSON_VALUE)) {\rString str = responseBody.string();\rJSONObject json = JSONObject.parseObject(JSON.toJSON(str));\rString data = json.getString(\u0026quot;data\u0026quot;);\rif (StringUtils.isNotBlank(data)) {\rResponseBody body = ResponseBody.create(okhttp3.MediaType.get(MediaType.APPLICATION_JSON_VALUE), data);\rreturn response.newBuilder().body(body).build();\r}\r}\r}\r}\rreturn response;\r}\r}\r 嗯，这样，interceptor就定义好了，接下来就是配置feign了~\n配置Feign 关于maven依赖修改啥的我就不说了，如果使用的spring-cloud-openfeign-dependencies，应该会包含okhttp的依赖。\n  修改application.yml\nfeign:\rhystrix:\renabled: true\rokhttp:\renabled: true\rhttpclient:\rconnectionTimeout: 30000\rclient:\rconfig:\rdefault:\rreadTimeout: 30000\r   添加FeignOkHttpConfig.java\n@Configuration\r@ConditionalOnClass(Feign.class)\r@AutoConfigureBefore(FeignLoadBalancerAutoConfiguration.class)\rpublic class FeignOkHttpConfig {\r@Autowired\rprivate OkHttpResponseInterceptor okHttpResponseInterceptor;\rprivate okhttp3.OkHttpClient okHttpClient;\r@Bean\r@ConditionalOnMissingBean(ConnectionPool.class)\rpublic ConnectionPool httpClientConnectionPool(\rFeignHttpClientProperties httpClientProperties,\rOkHttpClientConnectionPoolFactory connectionPoolFactory) {\rInteger maxTotalConnections = httpClientProperties.getMaxConnections();\rLong timeToLive = httpClientProperties.getTimeToLive();\rTimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit();\rreturn connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);\r}\r@Bean\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\rpublic okhttp3.OkHttpClient okHttpClient(OkHttpClientFactory httpClientFactory,\rConnectionPool connectionPool,\rFeignClientProperties feignClientProperties,\rFeignHttpClientProperties feignHttpClientProperties) {\rFeignClientProperties.FeignClientConfiguration defaultConfig = feignClientProperties.getConfig().get(\u0026quot;default\u0026quot;);\rint connectTimeout = feignHttpClientProperties.getConnectionTimeout();\rint readTimeout = defaultConfig.getReadTimeout();\rboolean disableSslValidation = feignHttpClientProperties.isDisableSslValidation();\rboolean followRedirects = feignHttpClientProperties.isFollowRedirects();\rthis.okHttpClient = httpClientFactory.createBuilder(disableSslValidation)\r.readTimeout(readTimeout, TimeUnit.MILLISECONDS)\r.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)\r.followRedirects(followRedirects)\r.connectionPool(connectionPool)\r.addInterceptor(okHttpResponseInterceptor)\r.build();\rreturn this.okHttpClient;\r}\r@PreDestroy\rpublic void destroy() {\rif (this.okHttpClient != null) {\rthis.okHttpClient.dispatcher().executorService().shutdown();\rthis.okHttpClient.connectionPool().evictAll();\r}\r}\r}\r   好的~ 这样基本上就配置完了。下面我来具体解释一下，这么配置就能生效的原因。（如果不需要负载均衡，可以参考百毒到的配置方案，那个应该也是ok的）\n解析   什么条件下配置的okhttp才会生效\n首先看org.springframework.cloud.openfeign.FeignAutoConfiguration\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnClass(OkHttpClient.class)\r@ConditionalOnMissingClass(\u0026quot;com.netflix.loadbalancer.ILoadBalancer\u0026quot;)\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\r@ConditionalOnProperty(\u0026quot;feign.okhttp.enabled\u0026quot;)\rprotected static class OkHttpFeignConfiguration {\r...\r}\r 只有当okhttp3.OkHttpClient这个Bean不存在时，才会启用OkHttpFeignConfiguration。\n然而我们在配置中需要修改interceptor必然会手动创建这个Bean，因此我们需要手动添加其他的配置。\n但是，先不要急，因为如果使用负载均衡，这个类还不是关键。\n  feign负载均衡FeignLoadBalancerAutoConfiguration\n@ConditionalOnClass(Feign.class)\r@ConditionalOnBean(BlockingLoadBalancerClient.class)\r@AutoConfigureBefore(FeignAutoConfiguration.class)\r@AutoConfigureAfter(FeignRibbonClientAutoConfiguration.class)\r@EnableConfigurationProperties(FeignHttpClientProperties.class)\r@Configuration(proxyBeanMethods = false)\r// Order is important here, last should be the default, first should be optional\r// see\r// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653\r@Import({ HttpClientFeignLoadBalancerConfiguration.class,\rOkHttpFeignLoadBalancerConfiguration.class,\rDefaultFeignLoadBalancerConfiguration.class })\rpublic class FeignLoadBalancerAutoConfiguration {\r}\r 不难发现，这个配置加载是在FeignAutoConfiguration之前的，因此，这个类对于我们而言更为关键。\n@Import({ HttpClientFeignLoadBalancerConfiguration.class,\rOkHttpFeignLoadBalancerConfiguration.class,\rDefaultFeignLoadBalancerConfiguration.class })\r 通过Import注解的信息，我们得知需要查看OkHttpFeignLoadBalancerConfiguration。\n  根据OkHttpFeignLoadBalancerConfiguration\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnClass(OkHttpClient.class)\r@ConditionalOnProperty(\u0026quot;feign.okhttp.enabled\u0026quot;)\r@ConditionalOnBean(BlockingLoadBalancerClient.class)\r@Import(OkHttpFeignConfiguration.class)\rclass OkHttpFeignLoadBalancerConfiguration {\r@Bean\r@ConditionalOnMissingBean\rpublic Client feignClient(okhttp3.OkHttpClient okHttpClient,\rBlockingLoadBalancerClient loadBalancerClient) {\rOkHttpClient delegate = new OkHttpClient(okHttpClient);\rreturn new FeignBlockingLoadBalancerClient(delegate, loadBalancerClient);\r}\r}\r 可以看出，这个配置类只生成了Client这个Bean，对于FeignAutoConfiguration中需要的剩下的Bean显然是不够的，因此，剩下的内容应该都在\n@Import(OkHttpFeignConfiguration.class)\r 这个Import的配置中，那么我们看看这个配置到底做了啥。\n  最后一步了~\n@Configuration(proxyBeanMethods = false)\r@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\rpublic class OkHttpFeignConfiguration {\rprivate okhttp3.OkHttpClient okHttpClient;\r@Bean\r@ConditionalOnMissingBean(ConnectionPool.class)\rpublic ConnectionPool httpClientConnectionPool(\rFeignHttpClientProperties httpClientProperties,\rOkHttpClientConnectionPoolFactory connectionPoolFactory) {\rInteger maxTotalConnections = httpClientProperties.getMaxConnections();\rLong timeToLive = httpClientProperties.getTimeToLive();\rTimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit();\rreturn connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);\r}\r@Bean\rpublic okhttp3.OkHttpClient client(OkHttpClientFactory httpClientFactory,\rConnectionPool connectionPool,\rFeignHttpClientProperties httpClientProperties) {\rBoolean followRedirects = httpClientProperties.isFollowRedirects();\rInteger connectTimeout = httpClientProperties.getConnectionTimeout();\rthis.okHttpClient = httpClientFactory\r.createBuilder(httpClientProperties.isDisableSslValidation())\r.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)\r.followRedirects(followRedirects).connectionPool(connectionPool).build();\rreturn this.okHttpClient;\r}\r@PreDestroy\rpublic void destroy() {\rif (this.okHttpClient != null) {\rthis.okHttpClient.dispatcher().executorService().shutdown();\rthis.okHttpClient.connectionPool().evictAll();\r}\r}\r}\r 很显然，这个类才是我们需要替换的，而且这个配置类的加载条件很简单\n@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)\r 我们只要自己创建这个Bean就可以了。\n那么，我们要做的就是在FeignLoadBalancerAutoConfiguration配置类加载之前，生成这个Bean，并根据OkHttpFeignConfiguration生成其他需要的Bean就可以了。具体参考 配置Feign 一节。\n ","date":"2021-04-06","permalink":"https://leejoker.github.io/post/feign%E4%BD%BF%E7%94%A8okhttp3%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/","tags":["springcloud","feign"],"title":"Feign使用okhttp3的正确姿势"},{"content":"  添加apt源到/etc/apt/sources.list文件\n$ sudo echo \u0026quot;deb [arch=amd64] http://packages.microsoft.com/repos/vscode stable main\u0026quot; \u0026gt;\u0026gt; /etc/apt/sources.list\r   添加gpg公钥\n$ sudo curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; /etc/apt/trusted.gpg.d/microsoft.gpg\r     如果提示找不到curl执行命令，请先安装curl\n$ sudo apt install curl\r   执行更新\n$ sudo apt update\r   安装vscode\n$ sudo apt install code\r   这样就可以通过apt命令对vscode进行更新了。\n以上~\n","date":"2021-03-08","permalink":"https://leejoker.github.io/post/ubuntu%E6%B7%BB%E5%8A%A0vscode%E6%BA%90/","tags":["linux","ubuntu","vscode"],"title":"Ubuntu添加vscode源"},{"content":"在项目中设置国内仓库 修改project.clj，参考如下内容进行设置\n(defproject project-name :dependencies [[org.clojure/clojure \u0026quot;1.10.0\u0026quot;]]\r:repositories [[\u0026quot;central\u0026quot; \u0026quot;http://maven.aliyun.com/nexus/content/groups/public\u0026quot;]\r[\u0026quot;clojars\u0026quot; \u0026quot;https://mirrors.tuna.tsinghua.edu.cn/clojars/\u0026quot;]])\r;; 这个是官方的启用非严格检查方案\r(require 'cemerick.pomegranate.aether)\r(cemerick.pomegranate.aether/register-wagon-factory!\r\u0026quot;http\u0026quot; #(org.apache.maven.wagon.providers.http.HttpWagon.))\r 7-10行的内容放在project.clj文件的最后，主要用于关闭高版本lein的严格仓库检查（非必需）。\n感谢音无麻里亚在Blog中提供的解决方案~~\n配置全局国内仓库 {:user\r{:mirrors {\r\u0026quot;central\u0026quot; {:name \u0026quot;aliyun\u0026quot;\r:url \u0026quot;https://maven.aliyun.com/repository/public/\u0026quot;}\r#\u0026quot;clojars\u0026quot; {:name \u0026quot;qinghua\u0026quot;\r:url \u0026quot;https://mirrors.tuna.tsinghua.edu.cn/clojars/\u0026quot;\r:repo-manager true}\r}\r:plugins []\r:repl-options {:init (use 'midje.repl)}\r;; :injections [(require 'cemerick.pomegranate.aether)\r;; (cemerick.pomegranate.aether/register-wagon-factory!\r;; \u0026quot;http\u0026quot; #(org.apache.maven.wagon.providers.http.HttpWagon.))]\r:dependencies [[midje \u0026quot;1.9.9\u0026quot;]]\r}\r}\r 感谢onedam在Blog中提供的解决方案~~\n特别说明 本文内容基本上都是转自网络，也附上了作者的地址和原文，感兴趣的同学可以去看看。\n我这里只是做个笔记，方便内容的整理和查询。\n以上。\n","date":"2021-03-04","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AEclojure%E5%9B%BD%E5%86%85%E4%BB%93%E5%BA%93/","tags":["clojure"],"title":"配置Clojure国内仓库"},{"content":"windows下转发虚拟机中的服务 PC C:\\Users\\leejoker\u0026gt; netsh interface portproxy add v4tov4 listenport=8080 listenaddress=10.10.1.233 connectport=8080 connectaddress=192.168.0.233\r 这个命令即可实现将虚拟机中的服务映射出去。\n listenport：物理机监听端口，其他局域网内的机器通过这个端口访问虚拟机中的服务 listenaddress：物理机监听的地址，本机ip connectport：虚拟机中服务暴露给本机的端口 connect address：虚拟机映射到本机的ip地址  其他命令参考   查看所有端口转发\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy show all\r   删除端口转发配置（删除时需要增加类型参数，例如v4tov4）\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=10.10.1.233\r   清空端口转发配置\nPC C:\\Users\\leejoker\u0026gt; netsh interface portproxy reset\r   结语 这个功能在windows里还是很好用的，尤其是需要在虚拟机里跑服务，你需要透传给同事进行测试的时候XD\n如果你不知道怎么把虚拟机里的服务映射到物理机，那么你可以去百度，或者用vagrant构建虚拟机。\n","date":"2021-01-11","permalink":"https://leejoker.github.io/post/windows%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","tags":["windows"],"title":"Windows端口转发"},{"content":"具体操作  添加docker group  $ sudo groupadd docker\r 添加用户到group  $ sudo gpasswd -a ${USER} docker\r 重启服务  $ sudo service docker restart\r 补充说明 这种方式适用于当root用户或者使用sudo可以执行，但普通用户无法执行的场景，不仅限于docker这一个服务，其他服务遇到此类情况的时候也不妨试一试~\n","date":"2020-12-29","permalink":"https://leejoker.github.io/post/%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cdocker%E5%91%BD%E4%BB%A4/","tags":["linux"],"title":"普通用户直接运行docker命令"},{"content":"IDEA升级到2020.3后，使用lombok会报以下错误：\njava: You aren't using a compiler supported by lombok, so lombok will not work and has been disabled. Your processor is: com.sun.proxy.$Proxy24 Lombok supports: sun/apple javac 1.6, ECJ  这个问题需要将lombok升级到1.18.16版本：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  解决！\n","date":"2020-12-07","permalink":"https://leejoker.github.io/post/idea%E5%8D%87%E7%BA%A72020.3%E5%90%8Elombok%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/","tags":["idea","技巧"],"title":"IDEA升级2020.3后lombok编译报错"},{"content":"起因 最开始是因为出差要跑公司的项目，为了省事在笔记本上装了Docker Desktop for Windows和docker版本的mysql，因为docker依赖hyper-v虚拟化，所以我就把他打开了。\n然后。。。我就发现，mumu模拟器居然不支持在开启hyper-v环境下启动，(╯‵□′)╯︵┻━┻，于是我几番折腾，找到了BlueStacks Hyper-V(测试版本)！\n当时我非常开心，以为终于找到了解决方案，于是开始安装FGO，运行，闪退。。。运行，闪退。。。。(╯‵□′)╯︵┻━┻\n无果，\u0026quot;[docker] 一遍、死んで见る\u0026quot;，docker 卒！\nvagrant搞起！谁也阻挡不了我玩FGO，现在可是无限池！！！\n开始安装吧！はじまるよ sudo apt install mysql-server # 记得做好备份 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf # 示例如下 [mysqld] skip-grant-tables lower_case_table_names=1 user\t= mysql pid-file\t= /var/run/mysqld/mysqld.pid socket\t= /var/run/mysqld/mysqld.sock port\t= 3306 datadir\t= /var/lib/mysql bind-address\t= 0.0.0.0 mysqlx-bind-address\t= 0.0.0.0 key_buffer_size\t= 16M myisam-recover-options = BACKUP log_error = /var/log/mysql/error.log max_binlog_size = 100M  重启mysql服务\nsudo service mysql restart  登录mysql，将root用户密码重置为空\nmysql -u root # 登录mysql后 use mysql update user set authentication_string='',host='%' where User='root'; update user set plugin=\u0026quot;mysql_native_password\u0026quot;; flush privileges; exit  修改配置文件后，重启服务\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf [mysqld] # skip-grant-tables 修改这一行就行 sudo service mysql restart  登录mysql\nmysql -u root -p # 这时候依旧不需要输入密码，直接回车，接下来要设置密码了 alter user 'root'@'%' identified by 'NewP@ssword'; flush privileges; exit # 再登录就需要输入密码了 mysql -u root -p show databases; # 如果到这里一切正常，那就没什么问题了 # 如果提示 The user specified as a definer ('mysql.infoschema'@'localhost') does not exist # 请尝试执行一下操作 mysql -u root -p update user set plugin = 'caching_sha2_password' where user='mysql.sys' or user='mysql.infoschema'; exit  结语 安装的过程中折腾了好几次吧，不知道为啥我用sudo居然不能启动mysql服务，必须使用root用户，就很奇怪，估计和vagrant环境有关，也懒得处理这个问题了。希望能帮助到其他学习的小伙伴，帮不上别人就权当笔记了，毕竟是我2020年下半年第一篇blog XD！\n","date":"2020-12-05","permalink":"https://leejoker.github.io/post/ubuntu%E5%AE%89%E8%A3%85mysql8/","tags":["linux","mysql"],"title":"Ubuntu安装mysql8"},{"content":"由于公司的网络问题，我用CCProxy挂了一个代理在能上网的机器上，利用代理上网。这两天对rust感兴趣，于是就开始按照官网的说明安装rustup。\n然后，问题来了！挂的代理居然不能访问！\n# vim /etc/environment 1 PATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/game 2 http_proxy=\u0026quot;http://ip:port\u0026quot; 3 https_proxy=\u0026quot;https://ip:port\u0026quot; 4 ftp_proxy=\u0026quot;ftp://ip:port\u0026quot; 5 socks_proxy=\u0026quot;socks://ip:port\u0026quot; 6 no_proxy=\u0026quot;localhost,127.0.0.1,localaddress,.localdomain.com\u0026quot;  在别的命令里面都是ok的，但是rustup这里就是不行。\n最后试了好久，发现像下面这么改就可以了，实在是百思不得其解，嘛~姑且记一下。\n# vim /etc/environment 1 PATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/game 2 http_proxy=ip:port 3 https_proxy=ip:port 4 ftp_proxy=ip:port 5 socks_proxy=ip:port 6 no_proxy=\u0026quot;localhost,127.0.0.1,localaddress,.localdomain.com\u0026quot; ","date":"2020-01-28","permalink":"https://leejoker.github.io/post/rustup%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","tags":["rust"],"title":"Rustup代理设置"},{"content":"这两天发现我在.gitignore文件中添加忽略后，每次提交已经被忽略的文件还是会出现在我的提交列表里，查了一下，应该是git缓存的问题，只要清理一下缓存就ok了。\n$ cd $YOUR_PROJECT_DIR $ git rm -r --cached . $ git add . $ git commit -m 'update .gitignore'  ","date":"2020-01-28","permalink":"https://leejoker.github.io/post/idea%E4%B8%AD%E7%9A%84git%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%BF%BD%E7%95%A5.gitignore%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9/","tags":["idea","技巧"],"title":"Idea中的Git无法正常忽略"},{"content":"安装rvm # 安装gnupg2 $ sudo apt install gnupg2 # 安装rvm $ gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB $ \\curl -sSL https://get.rvm.io | bash -s stable $ source ~/.bashrc # 替换ruby-china源 $ echo \u0026quot;ruby_url=https://cache.ruby-china.com/pub/ruby\u0026quot; \u0026gt; ~/.rvm/user/db # 替换gem源 $ gem sources -l $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ # 更新缓存 $ gem sources -u  安装rbenv 当然如果网络不佳，安装不了rvm，也可以使用rbenv\n# rbenv源码 $ git clone https://github.com/rbenv/rbenv.git ~/.rbenv # 用来编译安装 ruby $ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build # 用来管理 gemset, 可选, 因为有 bundler 也没什么必要 $ git clone https://github.com/jamis/rbenv-gemset.git ~/.rbenv/plugins/rbenv-gemset # 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐 $ git clone https://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update # 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐 $ git clone https://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror # 将下面的内容放入 .bashrc export PATH=\u0026quot;$HOME/.rbenv/bin:$PATH\u0026quot; eval \u0026quot;$(rbenv init -)\u0026quot; $ source ~/.bashrc  安装Ruby rvm # 列出ruby已知版本 $ rvm list known # 安装 $ rvm install 2.7.0 --disable-binary # 切换版本，并设为默认 $ rvm use 2.7.0 --default # 卸载 $ rvm remove 1.8.7  rbenv\n#更新rbenv及插件 $ rbenv update # 列出所有 ruby 版本 $ rbenv install --list # 安装 2.7.0 $ rbenv install 2.7.0 # 卸载 2.7.0 $ rbenv uninstall 2.7.0  安装Rails $ gem install rails # 安装完成后查看rails版本 $ rails -v  写在最后 安装过程中如果存在依赖或者其他问题，请自觉检索吧，这个不同机器可能会有不同的情况。本文内容大量参考了ruby-china的wiki，十分感谢~\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/%E5%AE%89%E8%A3%85ruby-on-rails/","tags":["ruby","rails"],"title":"安装Ruby on Rails"},{"content":"Mapper中的使用 在insert中增加下面两个属性，useGeneratedKeys和keyProperty\nuseGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;  如果数据库支持自增主键，这样就可以了。如果不行，需要自己创建序列，然后通过序列获取主键值(使用的是postgresql中的函数，其他数据库视具体情况而定)：\n\u0026lt;insert id=\u0026quot;insertValue\u0026quot; parameterType=\u0026quot;map\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;id\u0026quot; resultType=\u0026quot;java.lang.Long\u0026quot; order=\u0026quot;BEFORE\u0026quot;\u0026gt; SELECT nextval('sequence_name'::regclass) as id \u0026lt;/selectKey\u0026gt; insert into table_name \u0026lt;trim prefix=\u0026quot;(\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt; id, \u0026lt;/if\u0026gt; ... \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026quot;values (\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt; #{id,jdbcType=BIGINT}, \u0026lt;/if\u0026gt; ... \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt;  当然你也可以这样使用\n\u0026lt;insert id=\u0026quot;insertValue\u0026quot; parameterType=\u0026quot;map\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; keyProperty=\u0026quot;id\u0026quot;\u0026gt; insert into table_name \u0026lt;trim prefix=\u0026quot;(\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt; id, \u0026lt;/if\u0026gt; ... \u0026lt;/trim\u0026gt; \u0026lt;trim prefix=\u0026quot;values (\u0026quot; suffix=\u0026quot;)\u0026quot; suffixOverrides=\u0026quot;,\u0026quot;\u0026gt; \u0026lt;if test=\u0026quot;id != null\u0026quot;\u0026gt; (SELECT nextval('sequence_name'::regclass) as id), \u0026lt;/if\u0026gt; ... \u0026lt;/trim\u0026gt; \u0026lt;/insert\u0026gt;  这种使用方法也适用于批量执行插入的时候\n\u0026lt;insert id=\u0026quot;insertBatch\u0026quot; parameterType=\u0026quot;java.util.List\u0026quot;\u0026gt; insert into table_name ( id, ... ) values \u0026lt;foreach collection=\u0026quot;list\u0026quot; item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; separator=\u0026quot;,\u0026quot;\u0026gt; ((SELECT nextval('sequence_name'::regclass) as id), ...) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; ","date":"2020-01-10","permalink":"https://leejoker.github.io/post/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E4%B8%BB%E9%94%AE/","tags":["mybatis","java"],"title":"Mybatis中使用序列自动插入主键"},{"content":"今天在开发过程中遇到一个文件上传的问题\nio.undertow.server.RequestTooBigException: UT000020: Connection terminated as request was larger than 10485760  Servlet容器使用的是undertow，看异常信息应该是默认存在10MB的文件大小限制。\n百度了一下，找到如下配置，问题得以解决，记录一下\nspring: servlet: multipart: # 文件最大限制 max-file-size: 1024MB # 请求最大限制 max-request-size: 1024MB enabled: true # 设置文件缓存的临界点,超过则先保存到临时目录,默认为0,所有文件都会进行缓存 file-size-threshold: 0  ","date":"2020-01-10","permalink":"https://leejoker.github.io/post/springboot%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E5%A4%84%E7%90%86/","tags":["java","springboot"],"title":"Springboot上传文件大小限制处理"},{"content":"获取Yapi源码 在github上获取最新的yapi源码：\n$ git clone https://github.com/YMFE/yapi.git ~/yapi  通过npm或cnpm安装依赖：\n$ cd ~/yapi $ npm install  这样准备工作就完成了一半了，接下来安装mongodb。\n安装和配置MongoDB（Ubuntu 18.04） 一些说明 这一部分建议读完之后再进行操作，有些操作可能会产生一些问题，为避免不必要的麻烦，特此声明！\n安装MongoDB服务端 安装MongoDB的服务端可以通过官网进行下载，记得选择与自己系统相匹配的版本\n下载完成后，可以使用dpkg命令进行安装\n$ sudo dpkg -i mongodb-org-server_4.2.2_amd64.deb  创建mongodb的默认数据目录\n$ sudo mkdir -p /data/db  运行mongodb\n$ sudo mongod  这样，mongodb服务就启动了。\n安装MongoDB客户端 安装了服务端后，还要安装客户端才能够连接数据库进行控制，官网也提供了Mongo Shell，在Package处选择shell即可下载，不过由于是企业版本里的，我也没有去确认是否会收费，就没有尝试了。\n我用的是Ubuntu包管理里的mongodb-clients\n$ sudo apt install mongodb-clients  安装完成后，运行客户端\n$ mongo  PS：如果通过包管理安装了mongodb-clients，最好还是通过包管理安装mongodb，下载的服务端可能和包管理中的客户端版本不匹配，然后被包管理卸载掉服务端，/(ㄒoㄒ)/~~\n配置MongoDB 使用客户端连接mongodb后，需要创建yapi数据库\n\u0026gt; use yapi \u0026gt; db.yapi.insert({\u0026quot;name\u0026quot;:\u0026quot;init_data\u0026quot;})  当然，你也可以用MongoDB Compass操作数据库。\n添加用户\n\u0026gt; use yapi \u0026gt; db.createUser({ user: \u0026quot;yapi\u0026quot;, pwd: \u0026quot;123456\u0026quot;, roles: [ { role: \u0026quot;dbOwner\u0026quot;, db: \u0026quot;yapi\u0026quot; } ] })  如果发生\n Error: couldn’t add user: Use of SCRAM-SHA-256 requires undigested passwords\n 请增加 mechanisms 属性\n\u0026gt; use yapi \u0026gt; db.createUser({ user: \u0026quot;yapi\u0026quot;, pwd: \u0026quot;123456\u0026quot;, roles: [ { role: \u0026quot;dbOwner\u0026quot;, db: \u0026quot;yapi\u0026quot; } ], mechanisms : [\u0026quot;SCRAM-SHA-1\u0026quot;] })  对新增的用户进行验证\n\u0026gt; use yapi \u0026gt; db.auth('yapi','123456')  返回1的话就没有什么问题啦！记得一定要切换到对应数据库下建立用户！！！\n配置Yapi 创建config.json配置文件\n$ cd ~/yapi $ cp config_example.json config.json  修改config.json文件\n{ \u0026quot;port\u0026quot;: \u0026quot;3000\u0026quot;, \u0026quot;adminAccount\u0026quot;: \u0026quot;you_email_address@email.com\u0026quot;, \u0026quot;db\u0026quot;: { \u0026quot;servername\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;DATABASE\u0026quot;: \u0026quot;yapi\u0026quot;,\t//这里是刚才创建的mongo数据库 \u0026quot;port\u0026quot;: 27017, \u0026quot;user\u0026quot;: \u0026quot;yapi\u0026quot;,\t//这里是刚才创建的用户 \u0026quot;pass\u0026quot;: \u0026quot;123456\u0026quot;, \u0026quot;authSource\u0026quot;: \u0026quot;\u0026quot; }  最后就是运行Yapi了\n$ cd ~/yapi $ npm start \u0026gt; yapi-vendor@1.8.6 start /home/liang/projects/git/yapi \u0026gt; node server/app.js log: -------------------------------------swaggerSyncUtils constructor----------------------------------------------- log: 服务已启动，请打开下面链接访问: http://127.0.0.1:3000/ log: mongodb load success...  PS：不知道是不是我哪里弄得不对，在yapi的目录直接运行npm start会找不到config.json配置文件，因为提示config.json文件的路径在\u0026quot;../../config.json\u0026quot;，这个位置是相对\u0026quot;server/app.js\u0026quot;来说的，也就是yapi目录的上级目录，这个地方我不是很理解，所以我直接把文件里声明的路径改了。\n//文件路径是 ~/yapi/server/yapi.js const config = require('../../config.json'); //这里改成 ../config.json  这样Yapi目录中的config.json就可以正常生效了，log日志目录也可以采用类似的方式处理。\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/yapi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","tags":["工具"],"title":"Yapi的安装和使用"},{"content":"一般在使用sqlite的时候都是配置url为绝对路径，但是今天在测试代码的时候想到如果将 项目不到tomcat上之后，db文件总不能一直配置成绝对路径，肯定是项目中的某个位置， 因此对jdbc配置文件进行了修改：\njdbc.url=jdbc:sqlite:blog.db  db文件放在WEB-INF/classes下，运行后发现貌似没有问题，然而事实并不是这样QAQ\n因为测试中初始化代码会自动根据bean创建表格，我想是不是生成了一个新的db文件呢， 然后我把初始化关掉之后，果然报错了。。。。。。ORZ，然后我在tomcat的bin目录中 找到了崭新的db文件。\n百般尝试之后依旧如此，于是去看源码，然后在org.sqlite.core.CoreConnection中发现了这么一段：\nprivate static final String RESOURCE_NAME_PREFIX = \u0026quot;:resource:\u0026quot;; private void open(int openModeFlags, int busyTimeout) throws SQLException { // check the path to the file exists if (!\u0026quot;:memory:\u0026quot;.equals(fileName) \u0026amp;\u0026amp; !fileName.startsWith(\u0026quot;file:\u0026quot;) \u0026amp;\u0026amp; !fileName.contains(\u0026quot;mode=memory\u0026quot;)) { if (fileName.startsWith(RESOURCE_NAME_PREFIX)) { String resourceName = fileName.substring(RESOURCE_NAME_PREFIX.length()); // search the class path ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); URL resourceAddr = contextCL.getResource(resourceName); if (resourceAddr == null) { try { resourceAddr = new URL(resourceName); } catch (MalformedURLException e) { throw new SQLException(String.format(\u0026quot;resource %s not found: %s\u0026quot;, resourceName, e)); } } try { fileName = extractResource(resourceAddr).getAbsolutePath(); } catch (IOException e) { throw new SQLException(String.format(\u0026quot;failed to load %s: %s\u0026quot;, resourceName, e)); } } else { File file = new File(fileName).getAbsoluteFile(); File parent = file.getParentFile(); if (parent != null \u0026amp;\u0026amp; !parent.exists()) { for (File up = parent; up != null \u0026amp;\u0026amp; !up.exists();) { parent = up; up = up.getParentFile(); } throw new SQLException(\u0026quot;path to '\u0026quot; + fileName + \u0026quot;': '\u0026quot; + parent + \u0026quot;' does not exist\u0026quot;); } // check write access if file does not exist try { if (!file.exists() \u0026amp;\u0026amp; file.createNewFile()) file.delete(); } catch (Exception e) { throw new SQLException(\u0026quot;opening db: '\u0026quot; + fileName + \u0026quot;': \u0026quot; + e.getMessage()); } fileName = file.getAbsolutePath(); } } // load the native DB try { NativeDB.load(); db = new NativeDB(); } catch (Exception e) { SQLException err = new SQLException(\u0026quot;Error opening connection\u0026quot;); err.initCause(e); throw err; } db.open((SQLiteConnection)this, fileName, openModeFlags); setBusyTimeout(busyTimeout); }  这段代码的大概意思就是在非内存模式且url中开头不是以file：开头的情况下，先判断了url是否是以 :resource:开头，如果是，就以类加载路径进行寻找（获取类加载路径的绝对路径后加载数据库文件）， 否则就直接以url路径为绝对路径加载数据库文件\n于是对jdbc配置文件进行修改：\njdbc.url=jdbc:sqlite::resource:blog.db  搞定！！！\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AEsqlite%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","tags":["“java\"","jdbc"],"title":"配置sqlite的相对路径"},{"content":"使用Spacemacs国内镜像 最近开始使用emacs写一些clojure的代码，但是不挂梯子的话，源的更新确实不快，因此决定到网上搜索一下怎么配置国内镜像，不过搜索结果大概都是下面这个样子：\n# 基于emacs26 cd ~ git clone https://github.com/syl20bnr/spacemacs .emacs.d 修改 vim .emacs.d/core/templates/.spacemacs.template  (defun dotspacemacs/user-init () \u0026quot;Initialization function for user code. It is called immediately after `dotspacemacs/init', before layer configuration executes. This function is mostly useful for variables that need to be set before packages are loaded. If you are unsure, you should try in setting them in `dotspacemacs/user-config' first.\u0026quot; (setq configuration-layer--elpa-archives '((\u0026quot;melpa-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/\u0026quot;) (\u0026quot;org-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/org/\u0026quot;) (\u0026quot;gnu-cn\u0026quot; . \u0026quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/\u0026quot;))) )  其实也没什么问题，原文内也都说明了是在第一次初始化之前修改这个模板文件。\n不过对于已经配置过的，还是直接修改按照模板生成的配置文件 ~/.spacemacs 即可：\n;; 修改的位置基本不变，修改 ~/.spacemacs 文件 (defun dotspacemacs/user-init () \u0026quot;Initialization function for user code. It is called immediately after `dotspacemacs/init', before layer configuration executes. This function is mostly useful for variables that need to be set before packages are loaded. If you are unsure, you should try in setting them in `dotspacemacs/user-config' first.\u0026quot; (setq configuration-layer--elpa-archives '((\u0026quot;melpa-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/melpa/\u0026quot;) (\u0026quot;org-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/org/\u0026quot;) (\u0026quot;gnu-cn\u0026quot; . \u0026quot;http://elpa.emacs-china.org/gnu/\u0026quot;))) )  补充说一句 我看的blog里面很多提到了运行 emacs -nw 可以提升打开速度，但是这个是在linux前提下，是以no window模式打开的，windows里面不要用这个参数，无法打开应用窗口，而且会让系统变得莫名卡顿（win10下亲测）！\n","date":"2020-01-10","permalink":"https://leejoker.github.io/post/spacemacs%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/","tags":["emacs"],"title":"Spacemacs配置国内镜像"},{"content":" 十年磨一剑，霜刃未曾试\n　——贾岛\n 亮剑 　少侠们刚从师门中出来，准备闯荡江湖时，难免被前辈指导：”少侠，亮剑吧！“\n　此时，少侠们之间的差别就显现出来了。有的在师门勤奋磨剑，精于技艺。有的就是做做样子，整日浑浑噩噩，过着自以为快乐的生活，好吧，其实快乐也挺重要的。\n　我们回到前面亮剑的问题，作为一名剑客，在被挑战的时候，拿不出手就很羞耻了，当然，大部分初出茅庐的少侠都是拿不出手或者剑磨得并不怎么样的吧。\n　当然，对于大多数人来说，闯江湖的路，一开始都是这个样子。\n转折 　有的人呢，受挫之后幡然醒悟，而有的人则走上了逐渐堕落的过程，走向堕落的，他的江湖之旅可能也就止步于此，成绩寥寥，这里就不去赘述了。主要说说那些开始向好的方向发展的少侠们，他们有的进步神速，技艺提升的很快，剑呢也磨得锃光瓦亮，有的就相对进展缓慢，默默无闻。\n　少侠们多数都是追求的”十步杀一人，千里不留行“的感觉吧，可是”十年磨一剑“才是稳步提升的正确方式，然而真正做到”十年磨一剑“的，真的还是很少，有的人磨剑、练剑，后来发现他不适合，然后转去练刀、练枪了，也有不少人因而成了大侠。\n练剑 　闯荡江湖其实就是修行的过程，但不同的人走的道路还是不一样的。有的人走的是“他山之石，可以攻玉“的路子，博览群书，遍观各路秘籍，最后融会贯通，修成了极高的境界；有的人呢，走的是“一法通，万法通”的路子，精研一道，最后臻至化境，同样修成了正果。归根结底，修行到最后所有的招式都是次要的，最后要达到的终极目标都是“手中无剑，心中也无剑”这种至高的境界。\n　当然，有些人年纪轻轻就登堂入室了，而有些，可能终其一生也是不知门在何处，惜哉！\n后记 　这篇小文写的断断续续的，中间思路也很乱，写到“练剑”一节终于还是写不下去了。工作五年以来虽然自己的技艺得到了不小的提升，但是经过市场的一番检验之后，终究还是没有达到预期的目标(lll￢ω￢) ，内心之中多多少少还是有一些遗憾的。\n总结了一下自己的问题：\n 一是思考问题还是比较浅薄，没有深入去思考，没有多问一个为什么，现在看来，这一点是尤为重要的，想要路走的更远，还是要多去深入的思考，做到知其然更知其所以然； 其次呢，造成这一结果的原因可能还是因为中途掺杂了不少管理上的工作（虽然也包含我在这一方面考虑转型而做出的一些尝试），导致精力分散了不少，目前更是出现了小半年没有什么代码输出的情况 （苦笑，这一点也是我应当付出的代价，毕竟尝试总要付出代价的，不管成功，还是失败。  最后呢，我还是选择了技术这一条路。或许这条路并不是那么容易，但是我还是选择继续走下去，愿所有跟我一样选择这一道路的“剑客”们都能一路披荆斩棘，修成正果。\n不禁想起一句话：\n ​\t愿你出走半生，归来仍是少年\n​\t—— 孙衍\n","date":"2019-10-30","permalink":"https://leejoker.github.io/post/%E5%B0%91%E4%BE%A0%E4%B8%8E%E5%89%91/","tags":["杂文"],"title":"少侠与剑"},{"content":"JS整型的坑 昨天同事跟我说js在整型长度支持上有坑，我去查了一下确实是有些坑的。js对于数值的保存遵循IEEE 754 双精度浮点格式规范，采用了双精度存储，占用64bit。如图所示：\n  0到51位为尾数（也就是有效数）\n  52位到62位为指数。\n 如果使用无符号整数格式，则算术中使用的指数值是偏移的指数 - 对于IEEE 754 binary64情况，指数值1023表示实际零（即2 e - 1023为1， e必须是1023）。指数范围从-1022到+1023，因为-1023（全0）和+1024（全1）的指数是为特殊数字保留的。\n   最后一位为符号位，用来声明数值的符号，即正负。\n  那么可以发现，想保证结果无偏移的话只有e为1023，即有效数为 $$ 2*2^{52} = 2^{53} $$ 即js中长整型不超过\n\u0026gt; Math.pow(2,53) \u0026lt;· 9007199254740992  精度就不会丢失。坑啊(╯‵□′)╯︵┻━┻\nSpringboot中的处理 说一说我的处理方案吧，因为项目使用的fastjson，因此在网上看到的关于jackson的处理方式，诸如@JsonSerialize注解等方式都是不行的，使用SerializeFilter的话改动又太大，最后还是决定自己动手修改返回值类型吧。下面直接上代码：\npackage packagename.response; import org.springframework.core.MethodParameter; import org.springframework.http.MediaType; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.web.bind.annotation.RestControllerAdvice; import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice; import java.util.HashMap; @RestControllerAdvice public class ResponseHandler implements ResponseBodyAdvice { @Override public boolean supports(MethodParameter returnType, Class converterType) { //默认不进行拦截,返回值为false，拦截则返回true return true; } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { //对body进行处理 if (body instanceof HashMap) { HashMap\u0026lt;String, Object\u0026gt; finalJson = (HashMap\u0026lt;String, Object\u0026gt;) body; finalJson.forEach((key, value) -\u0026gt; { if (value instanceof Long) { finalJson.put(key, String.valueOf(value)); } }); } return body; } }  如代码所示，body就是返回值内容，对body的处理就是遍历里面的value，将类型为Long的value转化为字符串再塞回去。OK，just it is.\n结语 这个是这两天踩得一个小坑，重点其实不是处理部分，反而是了解了双精度的规范XD，里面关于数据偏移那部分的内容看得也是一知半解，如果内容中包含什么错误，也请路过的小伙伴给予指正，多谢~\n","date":"2019-09-05","permalink":"https://leejoker.github.io/post/js%E6%95%B4%E5%9E%8B%E7%9A%84%E5%9D%91/","tags":["java","javascript"],"title":"Js整型的坑"},{"content":"前言 最近的一个项目里面需要使用gradle打一个可执行的jar包，在网上看了一堆帖子照着做最后都不是很成功，最后终于参考StackOverflow上的帖子搞定了可执行jar包的打包脚本，因此做一个笔记对这个进行一下记录。\n这里是本文的正片 我的代码因为包含了groovy的代码，因此在脚本中包含了groovy的部分配置，如果不适用groovy请去掉相关内容。\nbuildscript { repositories { maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } } dependencies { classpath \u0026quot;com.github.jengelman.gradle.plugins:shadow:5.1.0\u0026quot; } } plugins { id 'java' id 'groovy' id 'application' id 'com.github.johnrengelman.shadow' version '5.1.0' } apply plugin: 'com.github.johnrengelman.shadow' apply plugin: 'java' apply plugin: 'groovy' apply plugin: 'application' group 'groupId of your project' //项目的groupid version '0.0.1' mainClassName = \u0026quot;your mainClassName\u0026quot; //项目main方法所在的类名，需要包含完整的包路径 sourceCompatibility = 1.8 repositories { mavenCentral() } //设置编译字符集 tasks.withType(JavaCompile) { options.encoding = \u0026quot;UTF-8\u0026quot; } sourceSets { main { groovy { srcDir 'src/main/groovy' // 指定groovy源码目录 } java { srcDir 'src/main/java' // 指定java源码目录 } resources { srcDir 'src/main/resources' //资源目录 } } } //这里添加你的依赖 dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile files('your class files path') testCompile group: 'junit', name: 'junit', version: '4.12' //集成groovy compile 'org.codehaus.groovy:groovy-all:2.5.8' //集成fastjson compile group: 'com.alibaba', name: 'fastjson', version: '1.2.59' } //使用shadow进行打包 shadowJar { baseName = 'baseName' classifier = null version = \u0026quot;0.0.1\u0026quot; manifest { attributes \u0026quot;Main-Class\u0026quot;: mainClassName } configurations = [project.configurations.runtime] //配置包中包含的依赖的jar包 }  然后使用shadowjar打包即可。\n","date":"2019-08-26","permalink":"https://leejoker.github.io/post/%E4%BD%BF%E7%94%A8gradle%E6%89%93%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E5%8C%85/","tags":["gradle","java"],"title":"使用gradle打可执行jar包"},{"content":"前言 事件的起因源自一次客户现场的调试，调试到一半，客户说办公系统突然登录不进去了Σ(っ °Д °;)っ，当时因为手头上的事还没有搞定，就顺手把客户的tomcat重启了，然后似乎就一切正常，我也没有太放在心上。然鹅，事情并没有这么简单。\n麻烦接踵而至 之后的几周里，几乎每隔两周服务就会异常一次，时间非常稳定，问题的表现也很简单，就是登录之后无法完成跳转，一直表现为加载中的状态，直到访问超时。处理方式也很简单粗暴，只要重启tomcat就好了(￣﹏￣；)，其实第一次的时候如果深究一下原因或许就能很快定位了，然而，现在就很麻烦了，因为客户的系统是内部系统，不与互联网连接，每次又急着用不能保留“死亡现场”，就只能通过日志进行判定。\n那就看日志吧 问题是！catalina.out日志里面没有任何登录相关的异常~(╯‵□′)╯︵┻━┻，出现的异常内容也和登录的问题无关。这就说明，至少与登录代码本身是没有什么关系的，那么原因是什么呢？我们做一下简单的分析：\n 硬盘空间满：这个是个很坑的问题，在运行中好像也不会产生什么明显的症状，但是一旦硬盘满了，日志无法正常写入，IO就会被阻塞了，然后整个tomcat就不好了，应用的运行自然会受到影响。 请求处理异常：就是在浏览器提交请求后，服务端抛出了异常导致请求没有正常被返回。 数据库服务异常：这个其实和上一点差不多，不过主要问题出在服务器上，上一点造成异常的原因会很多，当然，对于大部分问题来说可能都是NullPointerException（手动滑稽）。  在排除了第一点和第二点之后，问题就主要集中在第三点上，但是数据库本身是正常的，那肯定就是数据库连接出现了问题，问题应该就在c3p0连接池上了。连接池连接数被耗尽，导致登陆时无法正常获取数据库连接，进而无法正常响应请求。\n寻找证据 首先自然是寻找catalina.out日志啦，在里面确实发现了蛛丝马迹，虽然不是登录代码中抛出的数据库无法获取连接的异常，但是确实同一时间段内其他业务类里面抛出的问题。其次，我又手动添加了线程日志的获取以便进一步的取证，创建getlog.sh：\n#!/bin/bash pid=`ps aux | grep java | grep -v grep | awk '{print $1}'` jstack $pid \u0026gt;\u0026gt; logs/thread_log.`date +%Y%m%d`  在crontab中添加定时任务：\ncrontab -e */5 * * * * SCRIPTPATH/getlog.sh  根据后续的日志分析来说，确实是在获取数据库连接那里阻塞了。（原谅我没有截图，弄不出来╮(╯▽╰)╭）\n处理和原因 处理方式很简单，修改一下c3p0连接池的参数就好了\n\u0026lt;!-- 超过时间限制是否回收 --\u0026gt; \u0026lt;property name=\u0026quot;removeAbandoned\u0026quot; value=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;!-- 超时时限 --\u0026gt; \u0026lt;property name=\u0026quot;removeAbandonedTimeout\u0026quot; value=\u0026quot;60\u0026quot;\u0026gt;  只修改了这个就ok了，因为原来连接数分配的是相对充足的，只是连接一直没有得到正确的释放。这就要继续追问了，为啥没有正确释放呢？\n 一般情况下，使用sessionFactory.openSession()的话，会因为session过多且没有关闭导致连接数溢出，但是我的代码里使用的是sessionFactory.getCurrentSession()，session不会被多次创建。\n最后发现是后来添加的定时任务报错了，最开始c3p0连接池设置的超时回收时间长达3小时！你没有看错，3小时！然后这个定时任务就把连接数逐渐蚕食掉了，而且很稳定的2周挂一次。\n总之，这是一个悲伤的故事，请大家引以为戒，如果能够给大家带来帮助，那就是最好的了。\n完结，撒花，★,°:.☆(￣▽￣)/$:.°★ 。\n","date":"2019-05-28","permalink":"https://leejoker.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E5%81%87%E6%AD%BB%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/","tags":["linux","java"],"title":"记一次登录假死的异常排查"},{"content":"从开发到实施XD 因为公司一个小项目要求有负载和热备，于是翻了很多网上的教程，于是找到了这一篇blog,很感谢博客的作者MassiveStars，这篇博客也使我学到了不少关于nginx配置的知识，毕竟以前连nginx都没有碰过XD。本博客大部分内容可能和作者的博客内容雷同，毕竟只是作为笔记存在的东西，侵删。\n配置虚拟IP 互为主从模式 互为主从模式需要配置两个vip（虚拟ip）进行负载，因此是需要负载均衡支持的哟~\n主从模式 即一个服务器为主（master），一个服务器为从（slave），在使用的时候，如果主异常则切换到从服务器，若主服务器恢复，则切回主服务器\nPS：这种模式的弊端就是，当由从向主切换的时候，如果从服务器正在执行操作，可能会产生错误~\n配置方法 ifconfig eth0:0 192.168.40.151 netmask 255.255.255.0 up\neth0: 用ifconfig命令查到的正在使用的网络设备名称，虚拟ip的命名必须采用此规则，建立在某一网络设备下\n配置nginx 安装nginx PS:我用的是ubuntu和opensuse，centos应该类似，建议上网把包down下来编译安装，这样更靠谱一些，当然，用yum安装也没有问题，方法类似\n#安装nginx leejoker@ubuntu:~$ sudo apt-get install nginx  配置nginx服务 #接下来是配置nginx leejoker@ubuntu:~$ sudo vim /etc/nginx/nginx.conf #PS:这里说明一下，不同的发行版，默认配置可能不同，我是现将默认配置进行了备份，然后重新写了一份，贴上自己的当前配置 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' # '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' # '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8080; #本地端口 server_name 192.168.40.151; #本地域名 location / { #代理配置 proxy_pass http://192.168.17.71:7003; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } #charset koi8-r; #access_log logs/host.access.log main; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} }  基本上这样就配置完了，本地域名（一般为dns可以解析的域名，自己测试的时候使用的ip）。\n启动nginx #启动nginx leejoker@ubuntu:~$ sudo nginx  配置keepalived 安装keepalived #安装keepalived leejoker@ubuntu:~$ sudo apt-get install keepalived  配置keepalived 先来个图这是第一台机器的配置 创建配置文件：sudo vim /etc/keepalived/keepalived.conf\nglobal_defs { notification_email { 1056650571@qq.com } notification_email_from 1056650571@qq.com smtp_server 127.0.0.1 stmp_connect_timeout 30 router_id LVS_DEVEL } vrrp_script Monitor_Nginx { script \u0026quot;/usr/local/keepalived/scripts/monitor_nginx.sh\u0026quot; interval 2 weight 2 } # 虚拟IP1, 本机作为Master vrrp_instance VI_1 { state MASTER interface ens33 #这里就是图上的那个，你的配置文件中用到的网络设备全部写这个 virtual_router_id 151 priority 100 advert_int 1 track_interface { ens33 } authentication { #这个是两个keepalived之间通信的凭证 auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.40.151 #这里填写本机配置的虚拟ip } track_script { Monitor_Nginx } } # 虚拟IP2, 本机作为Backup vrrp_instance VI_2 { state BACKUP interface ens33 #这里是本机作为backup时用到的网络设备 virtual_router_id 152 priority 100 advert_int 1 track_interface { ens33 } authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.40.152 #这里是本机作为backup时的虚拟ip } track_script { Monitor_Nginx } }  第二台的配置 global_defs { notification_email { 123456@qq.com } notification_email_from 123456@qq.com smtp_server 127.0.0.1 stmp_connect_timeout 30 router_id LVS_DEVEL } vrrp_script Monitor_Nginx { script \u0026quot;/usr/local/keepalived/scripts/monitor_nginx.sh\u0026quot; interval 2 weight 2 } # 虚拟IP1, 本机作为BACKUP vrrp_instance VI_1 { state BACKUP interface eth0 virtual_router_id 151 priority 100 advert_int 1 track_interface { eth0 } authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.40.151 } track_script { Monitor_Nginx } } # 虚拟IP2, 本机作为Master vrrp_instance VI_2 { state MASTER interface eth0 virtual_router_id 152 priority 100 advert_int 1 track_interface { eth0 } authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.40.152 } track_script { Monitor_Nginx } }  配置的内容类似，只不过网络设备上有些差异，就不多说了。\n启动keepalived sudo /usr/sbin/keepalived -f /etc/keepalived/keepalived.conf  PS:声明一下，关于keepalived的日志网上大多都是说在/var/log/messages下，不过我今天使用的发行版，日志都是和系统日志混在一起的，所以查阅日志的话请自行百度。\nPS:补上我的日志文件路径：/var/log/syslog (ubuntu) 和 jounalctl (opensuse)\n最后补上nginx监控脚本 # 监控nginx进程，若nginx主进程不存在则启动nginx # 若5s后nginx进程还是不存在的话kill掉keepalived进程,防止nginx没运行该主机的keepalived还接管虚拟IP #!/bin/bash if [ \u0026quot;$(ps -ef | grep \u0026quot;nginx: master process\u0026quot;| grep -v grep )\u0026quot; == \u0026quot;\u0026quot; ] then /usr/sbin/nginx # 路径请以实际安装路径为准 sleep 5 if [ \u0026quot;$(ps -ef | grep \u0026quot;nginx: master process\u0026quot;| grep -v grep )\u0026quot; == \u0026quot;\u0026quot; ] then killall keepalived fi fi  总结 按照上面这样配置基本上就完成了互为主从模式的配置，单纯主从模式只是去掉其中的一部分配置，具体可以百度进行参考，就不在这里赘述了。\n","date":"2019-05-21","permalink":"https://leejoker.github.io/post/nginx-keepalived%E9%85%8D%E7%BD%AE%E7%83%AD%E5%A4%87%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/","tags":["linux","部署设计"],"title":"Nginx+keepalived配置热备（互为主从）"},{"content":"线性表 线性表是一个存储相同类型数据元素的有限序列。\n这里面需要关注的两个点就是，相同类型的数据、有限序列。\n线性表包含两种类型：\n 顺序表。使用一段地址连续的存储单元依次存储线性表的数据元素。 链表。使用一组任意的存储单元存放线性表的元素。   顺序表 顺序表的特性  顺序表使用的一段连续的存储空间，因此只要知道存储顺序表的起始地址，就可以计算表中任意位置元素的地址。所以，计算任意一个元素的存储地址的时间是相等的 由于上述特性，顺序表具有随机存取的特性。 顺序表存取操作的时间复杂度为O(1)。  顺序表的实现 下面就是一个简单的顺序表的实现：\npublic class SeqList { //长度 private int length = 0; //数据存储 private Object[] datas; //声明线性表最大长度 private final int MAXSIZE = 100; public SeqList(Object[] datas, int len) throws Exception { if (len \u0026gt; MAXSIZE) { throw new Exception(\u0026quot;初始化失败，长度超过允许的最大值\u0026quot;); } //这里使用最大长度去初始化线性表 this.datas = new Object[MAXSIZE]; for (int i = 0; i \u0026lt; len; i++) { this.datas[i] = datas[i]; this.length = len; } } //获取坐标为i的元素 public Object get(int i) throws Exception { if (i \u0026lt; 0 || i \u0026gt; length - 1) { throw new Exception(\u0026quot;查找位置错误\u0026quot;); } else { return this.datas[i]; } } //根据值获取index public int getIndex(Object data) { for (int i = 0; i \u0026lt; length; i++) { if (data.equals(datas[i])) { return i; } } return -1; } //插入操作 public void insert(Object data, int index) throws Exception { if (index \u0026lt; 0 || index \u0026gt; length) { throw new Exception(\u0026quot;插入位置错误\u0026quot;); } else if (index \u0026gt;= MAXSIZE) { throw new Exception(\u0026quot;上溢\u0026quot;); } else { for (int i = length - 1; i \u0026gt; index; i--) { datas[i + 1] = datas[i]; } datas[index] = data; length++; } } //删除操作 public void delete(int index) throws Exception { if (index \u0026lt; 0 || index \u0026gt; length) { throw new Exception(\u0026quot;删除位置错误\u0026quot;); } else if (length == 0) { throw new Exception(\u0026quot;下溢\u0026quot;); } else { System.out.println(\u0026quot;删除的元素为：\u0026quot; + datas[index].toString()); for (int i = index; i \u0026lt; length; i++) { datas[i] = datas[i + 1]; } length--; } } //判空 public boolean isEmpty() { if (length == 0) { return true; } else { return false; } } //遍历 public void printList() { for (int i = 0; i \u0026lt; length; i++) { System.out.println(datas[i]); } } public int getLength() { return length; } }  我们知道，Java中ArrayList类就是一个顺序表，其实现的基本原理也和上述代码差不多，但是ArrayList是包含一个自动增长的机制的，下面我们就简单分析一下这个自增长机制。\nArrayList的自增长 首先说一下ArrayList的初始化：\nprivate static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; // non-private to simplify nested class access public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026quot;Illegal Capacity: \u0026quot;+ initialCapacity); } } public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } }  从构造函数可以看出，默认生成的是一个空的数组，默认的容量是10。\npublic boolean add(E e) { ensureCapacityInternal(size + 1); //新增一个元素时，根据当前长度扩容 elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //当前数组为空时，根据传入的长度和默认容量确认应该采用哪个值进行容量需求的确认 } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length \u0026gt; 0) //当容量需求大于当前长度时（这个是存储的数组的长度，而非实际存储内容的size），执行增长 grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //增长策略为 newCapacity = oldCapacity+(oldCapacity/2) if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; //如果增长后仍不满足需求，则使用实际需求容量 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); }  以上就是ArrayList的自动增长的策略了，简单点来说就是先判断当前容量是否满足插入，如果不满足，执行扩容（扩容策略为 新容量=原容量 + （原容量/2）），如果仍不满足，就是用当前需要的容量值作为扩容结果。（没有考虑超过MAX_ARRAY_SIZE的情况）\n结语 线性表先写到这里吧，后面一篇就是把链表的部分补完，如果有什么问题，请路过的大佬予以补充~如果有人提问请在下方评论区提问，么么哒~\n","date":"2019-02-05","permalink":"https://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C/","tags":["算法","数据结构","Java"],"title":"数据结构与算法学习系列(二)"},{"content":"这个系列还会继续的 忽然发现我之前已经建立了这篇博客，心想姑且把这篇完成吧，后续更高级的内容等我琢磨明白了再放出来。这个系列并不是一个单纯学习教程，更是我对Clojure认知的一种体现吧，说实话从java这种语言跳到clojure上还是有挺多问题的，至少思维方式可能就需要进行蛮大的转变，后续估计还会在读一些SICP之类的内容去逐渐加深自己对于LISP这个深坑的理解。\n说一说常用的东西 这一节就来说一说常用的一些函数，在实际的应用中不论是刷题还是实际的开发应用，都会经常的用到，比如递归 map reduce apply 等等，这些都是接触clojure之后都会经常看到，用到的方法。那么，今天就来说说这些吧。\n递归 递归的话在一般的语言中（没错，我说的就是Java），一般都会采用这种方式：\npublic int doMethod(int param){ // do something doMethod(param); }  在方法内部调用方法本身实现递归，完成方法的递归调用。\n然而，在clojure中这种方式虽然可以，但却会造成堆栈的溢出（因为Clojure的尾递归优化不是用的原函数名,而是使用的recur，使用原函数名会不断产生新的实例从而造成堆栈溢出）。\n(defn recur-fibo [n] (letfn [(fib [current next n] (if (zero? n) current ;recur将递归调用fib函数 (recur next (+ current next) (dec n))))] (fib 0 1 n)))  上面这个例子摘自Clojure的recur尾递归优化探秘。文章主要表达的意思是，在方法实现方法实例后，每次刷新存储的参数，然后通过invoke调用方法实例实现尾递归优化。感兴趣的同学可以去仔细读一读庄晓丹大佬对于recur的解读，更为深入。\nmap reduce apply map reduce apply都是遍历执行的方法，不过map、reduce和apply的返回值不太一样。\nmap map返回的是一个lazy sequence,根据map的文档描述中可以知道，map是遍历所有传入参数，然后将每个参数执行传入函数的结果作为随后lazy-seq的元素。\n(map #(+ 1 %) (range 10)) ;; user=\u0026gt; (map #(+ 1 %) (range 10)) ;; (1 2 3 4 5 6 7 8 9 10)  apply apply的参数有两部分，一个是执行的函数，另一部分是执行函数的参数。\napply会依次传入参数并执行函数。\n(apply + 1 [2 3 4 5]) (apply + [1 2 3 4 5]) ;; user=\u0026gt; (apply + 1 [2 3 4 5]) ;; 15 ;; user=\u0026gt; (apply + [1 2 3 4 5]) ;; 15  但是要注意，apply传入的参数必须能够是一个列表，否则会造成类型识别失败。\nuser=\u0026gt; (apply + 1 2 3 4 5) IllegalArgumentException Don't know how to create ISeq from: java.lang.Long clojure.lang.RT.seqFrom (RT.java:542)  reduce reduce和apply类似，但是reduce中传入的函数中，函数的参数必须是两个。\n(reduce + [1 2 3 4 5]) ;;=\u0026gt; 15 (reduce + []) ;;=\u0026gt; 0 (reduce + [1]) ;;=\u0026gt; 1 (reduce + [1 2]) ;;=\u0026gt; 3 (reduce + 1 []) ;;=\u0026gt; 1 (reduce + 1 [2 3]) ;;=\u0026gt; 6 (def x {:a 1 :b 2}) (reduce (fn [p [k v]] (into p {k (+ 1 v)})) {} x) ;;=\u0026gt; {:a 2, :b 3}  结语 其实还有很多遍历的方法，比如在递归中用的很多的loop。还有for这个和java中的关键字长得很像的函数。但是由于我掌握的其实也很有限，在这一篇里就不再进行具体讲述了。在后续的章节里，我会逐渐加深内容的深度。这一篇就姑且到这里吧o(￣▽￣)ブ\n","date":"2019-02-04","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E5%9B%9B/","tags":["clojure","学习笔记"],"title":"clojure读书笔记其四"},{"content":"关于新坑和旧坑的说明 我又开了一个新的坑，迫于近期一些方面的压力，我又把数据结构和算法这个东西捡起来了，至于之前Clojure学习笔记系列的坑，咳咳，虽然还会更新下去，但是估计会延后很多了，因为学了Clojure蛮久的时间了，没有太多的实践机会，也没有对Clojure理解的足够深，因此这个系列估计会稍微放一放，等我理解足够深刻了在继续下去（对不起，还是因为懒XD）。\n什么是算法 算法，这个东西其实是思路的体现，也可以说是问题的解决方案。相信大家也都看到过这句话：\n 程序=算法+数据结构\n 虽然这么说或许不够准确，但是算法对于程序本身而言意义是十分重大的。也是影响程序性能的一个关键因素。大多时候算法都是一个由实际问题转化而成的数学模型，因此，像写出一个好的算法的话首先要能充分理解问题，然后就是将问题转化成一个高效的数学模型。所以说啊，学好数学还是很关键滴~\n什么是数据结构 数据结构是承载数据的（逻辑结构+存储结构）的总和，逻辑结构体现了数据元素之间的逻辑关系和元素自身的逻辑特性，而存储结构则是数据元素在存储设备上的存在形式。同时，存储结构也是逻辑结构在物理设备上的体现，存储的方式在一定程度上体现了数据元素之间的逻辑关系。\n一些概念的笔记 这部分算是一些基本概念的笔记，考试专用哦XD，虽然没什么太大的用处，但是也体现了数据结构和算法的一些根本原则，对于初学者而言还是有必要了解一下。\n  算法是对特定问题求解步骤的一种描述，是指令的有限序列 算法的五个重要特性：输入、输出、确定性、有穷性、可行性 “好”算法的五个特性：正确性、健壮性、可理解性、抽象分级、高效性 算法的描述方法：自然语言、流程图、程序设计语言、伪代码 时间复杂度和空间复杂度   这里简单地解释一下其中可能有迷惑的一些概念。\n 确定性：简单来说就是算法在不改变参数的前提下，其结果是确定的，不会变化的。相同的输入一定带来相同的输出。 有穷性：算法一定是可以结束的，这里指的是实际应用场景下而非算法结果本身（比如我的算法是产生一个无限的素数队列，但是我实际只需要截取前几位或固定位数，那么对于我而言算法就是有穷的）。 抽象分级：简单来说就是对算法不同部分的划分，哪一部分的算法是用来做什么的，其结果又用于哪个部分中作为参数。算法是一个相对整体的概念，但是中间的过程需要做出分割以便其他人能够理解和修改。 流程图和伪代码：这个意思我就不解释了，但是流程图和伪代码应该多去学习和理解，尤其是流程图，在工作之后很多时候是个很好的工具，而伪代码则是在忽略语法细节时最好的代码表现形式（其实就是忘了这里咋写了，然后大概写一下，滑稽XD）。 时间复杂度和空间复杂度：现在是一个硬件过剩的时代，空间复杂度往往是被大家忽略的一点，很多时候甚至会拿空间换时间，所以说时间复杂度的优化往往是性能提升的重头戏。但是！空间复杂度在整体设计上其实是很关键的一环，优秀的设计能大大缓解存储资源吃紧，提升程序效率（扩容啊啥的设计的烂的话太要命了）。还有，时间复杂度的分析要好好学哦，这里就不多说了，但是考试会考到~  几种算法的设计思路  蛮力法：采用一定策略依次处理求解问题的所有数据，即遍历数据集的方式，通常性能较低，用于处理较为基本的问题。 分治法：将问题分解为更小的规模然后各个击破，最后合并所有子模式的结果。如二叉树的遍历，深度优先遍历，快速排序等。 减治法：将问题分解为更小规模的问题，只需要解决其中一个小规模问题即可获得结果，无需合并所有子模式的结果。如插入排序，拓扑排序。 贪心法：将问题分解为一系列简单局部最优选择，每一步选择都是对当前解的扩展。如哈夫曼算法，Prim算法等。 动态规划法：将问题分解成若干子问题，但是子问题间并非相互独立，根据子问题间的关系动态规划函数。如FLOYD算法。  本篇结语 这一篇只是一篇引子，你可以当我又水了一篇文章，哈哈~不过，对于初学算法和数据结构的人而言，最初的认识往往是最重要的，对知识有一个完整的认识非常重要，可以让人更为明确所学的东西是什么，有什么，包含哪些内容，学习的目标或者最终达成的效果是什么，我要不要学etc. 这些其实都能从一个整体的概述中获取到。平时读书也是一样，先读一下序，看看作者或者其他人对于书的整体内容的认知是什么样的，可以迅速帮你确认这是不是你想看的内容。\n后续内容说明 如果大佬看到篇文章可以尽情吐槽我，因为确实菜啊，毕业后好多知识都还给老师了，还是从最基础的开始学习。也是帮助刚开始进行学习这些的孩纸，我会把学校的教材从头到尾捋一遍，当然会根据不同的内容进行整理哒~也希望能帮助到看到这篇文章的萌新们XD\n","date":"2019-02-03","permalink":"https://leejoker.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80/","tags":["算法","数据结构","Java"],"title":"数据结构与算法学习系列（一）"},{"content":"lein与私有仓库 lein在new一个新的项目的时候都会从maven或者clojars上下载对应的依赖，但是一旦你离开了互联网环境只有一个maven私服的时候，这一切就变得不是那么美好了。因此，我们需要配置一下lein，让它能够从我们指定的位置下载依赖。\n创建profiles.clj 在$HOME/.lein/下创建profiles.clj文件，在其中添加如下内容：\n{ :user { :mirrors { \u0026quot;central\u0026quot; { :name \u0026quot;nexus-maven\u0026quot; :url \u0026quot;https://ip:port/repository/maven-central/\u0026quot; } \u0026quot;clojars\u0026quot; { :name \u0026quot;nexus-clojure\u0026quot; :url \u0026quot;https://ip:port/repository/clojars/\u0026quot; } } :certificates [\u0026quot;path of nexus.pem\u0026quot;] } }  clojure默认是不允许使用http的仓库，因此必须使用https的链接，并在certificates里配置相应的证书，这样lein在加载依赖的时候就可以自动通过设置的maven仓库下载依赖了。\n配置nexus使用https 根据官方文档中说明，需要进行如下步骤：\n  在$install-dir/etc/ssl/下创建keystore文件keystore.jks\n  在$data-dir/etc/nexus.properties文件中添加 application-port-ssl=8443\n  在$data-dir/etc/nexus.properties文件nexus-args属性中添加${jetty.etc}/jetty-https.xml，如下所示：\nnexus-args=${jetty.etc}/jetty.xml,${jetty.etc}/jetty-http.xml, \\ ${jetty.etc}/jetty-https.xml,${jetty.etc}/jetty-requestlog.xml    在$install-dir/etc/jetty/jetty-https.xml中配置keystore文件的密码，如果你没有设置keystore的密码这一步就可以忽略\n  到这一步位置其实nexus的https就已经配置好了，但是lein的certificates的证书貌似需要使用pem文件，因此需要自己转换成pem文件并放在自己指定的路径下就可以了。\nkeystore文件生成和转换 官方文档中其实包含证书生成的内容，我这里就进行简单的copy了 XD。\n 生成证书库和证书：  keytool -genkeypair -keystore example.jks -storepass password -alias \\ example.com -keyalg RSA -keysize 2048 -validity 5000 -keypass password \\ -dname 'CN=*.example.com, OU=Sonatype, O=Sonatype, L=Unspecified, \\ ST=Unspecified, C=US' -ext \\ 'SAN=DNS:nexus.example.com,DNS:clm.example.com,DNS:repo.example.com, \\ DNS:'www.example.com'  转换为PKCS12证书：  keytool -importkeystore -srckeystore example.jks -destkeystore example.p12 -deststoretype PKCS12  将PKCS12证书转换为openssl证书：  openssl pkcs12 -nokeys -in example.p12 -out example.pem  通过以上步骤就完成了pem证书的生成，然后在profiles.clj中certificates属性里进行配置就可以了。\n完结撒花★,°:.☆(￣▽￣)/$:.°★ 。\n","date":"2018-11-01","permalink":"https://leejoker.github.io/post/%E9%85%8D%E7%BD%AElein%E7%9A%84%E7%A7%81%E6%9C%89%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93/","tags":["clojure","lein","nexus"],"title":"配置lein的私有依赖仓库"},{"content":"Namespace 名称空间对于Clojure来说是一个逻辑上对于代码进行分组的概念，类似于Java的package，通过使用名称空间能够规避方法名冲突，有效的对代码进行管理。主要应用的话，其实就是方便代码的引入和使用了，毕竟你不可能将所有代码放到一个clj文件中。\ncreate-ns user\u0026gt; (create-ns 'clojure.by.example)\rnil\r 这样一个名称空间就建立好了，是不是so easy！\nin-ns ;; create the namespace and switch to it\r(in-ns 'first-namespace)\r in-ns的主要作用是切换到指定的namespace中，如果这个namespace不存在，则会创建他。\nrequire/refer/use 这三个要放在一起来说，因为他们的作用都是引入一个namespace，但是使用细节上略有不同。\nrequire require的作用最为纯粹，就是单纯的引入一个namespace。\n;; 最简单的使用\ruser\u0026gt; (require 'clojure.by.example)\rnil\r;; 当然你也可以起个别名\ruser\u0026gt; (require '[clojure.by.example :as cbe])\rnil\r;; 当然你还可以引入多个\ruser\u0026gt; (require '[clojure.by.example :as cbe]\r'[clojure.core :as cc])\rnil\r 引入namespace后，你就可以调用namespace中的方法了。\nuser\u0026gt; (cbe/your_function_name)\r refer/use refer的作用是绑定一个namespace到当前namespace，这样你就可以直接使用函数名来调用函数，而不需要前面的namespace了。\nuser\u0026gt; (refer 'clojure.by.example)\rnil\ruser\u0026gt; (your_function_name)\r refer的使用存在一定问题，就是后引入的namespace中如果方法名与当前namespace或之前引入的namespace中存在冲突，会自动覆盖这些冲突，而且你无法在引入之后重新定义这些函数，会抛出异常。\n;; 就是下面类似的这种异常\rCompilerException java.lang.IllegalStateException: join already refers to: #'clojure.string/join in namespace: user, compiling:(null:1:1)\r refer还可以单独引入namespace中的特定方法。\n;; 引入的namespace中的方法为了避免冲突是可以进行重命名的\ruser=\u0026gt; (refer 'clojure.string\r:rename '{capitalize cap, trim trm})\r;; only可以单独引入namespace中的指定方法，但是方法名必须是原名，而不能是经过rename之后的名字\ruser\u0026gt; (refer ‘clojure.string :only ‘[capitalize trim]) ;; 这样写就会抛出异常\ruser=\u0026gt; (refer 'clojure.string\r:rename '{capitalize cap, trim trm}\r:only '[cap trm])\rIllegalAccessError cap does not exist clojure.core/refer (core.clj:3849)\r 而use就是将require和refer合二为一的函数，这里就不再赘述了。\nimport import是clojure中专门用来引入java包的函数。\nuser=\u0026gt; (import java.util.Date)\rjava.util.Date\ruser=\u0026gt; (new Date)\r#inst \u0026quot;2018-01-21T09:49:55.468-00:00\u0026quot;\r ns ns方法感觉是引入namespace中相对常用的函数。\n(ns example.namespace\r(:require [clojure.java.io])\r(:use [clojure.data])\r(:import [java.util List Set]))\r","date":"2018-01-21","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%B8%89/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其三"},{"content":"配置国内插件源 atom这个编辑器确实很好用，但是她的插件安装的速度实在是让人难受，没有梯子的话会让人抓狂w(ﾟДﾟ)w，在网上查了一下，找到了一个比较靠谱的方案，记下来方便以后使用。\n 本方法在linux和windows下都是可用的 在**$HOME/.atom目录下新建.atomrc**文件 在文件内添加如下内容：  registry=https://registry.npm.taobao.org/ strict-ssl=false  Over !\n","date":"2018-01-15","permalink":"https://leejoker.github.io/post/atom%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90/","tags":["atom","配置"],"title":"Atom配置国内源"},{"content":"今天的主题是Function 正如标题所言，今天这篇笔记的主题是function，当然也就是lisp语言中的一等公民，\u0026ldquo;函数\u0026quot;啦XD\n那么直入主题，首先来看一下怎么定义一个函数： ;; name params body ;; ----- ------ ------------------- (defn greet [name] (str \u0026quot;Hello, \u0026quot; name) )  这里我引用了官方文档中的说明。\n那么这个函数的使用就可以像上一篇中所说的那样：\nuser=\u0026gt; (greet \u0026quot;小明\u0026quot;) \u0026quot;Hello, 小明\u0026quot;  你也可以给你的方法增加方法说明： (defn greet \u0026quot;this is the greet function for you\u0026quot; [name] (str \u0026quot;Hello, \u0026quot; name))  文档说明可以用doc函数去查看: (doc greet) ;;---------------------------------- user/greet ([name]) this is the greet function for you  函数是支持定义多种参数列表的 (defn messenger ([] (messenger \u0026quot;Hello world!\u0026quot;)) ([msg] (println msg)))  当传入不同的参数的时候，会根据参数列表执行不同的函数体。\n但执行的方法没有匹配的参数列表时：\n(messenger \u0026quot;aaa\u0026quot; \u0026quot;bbbb\u0026quot;) ArityException Wrong number of args (2) passed to: user/messenger clojure.lang.AFn.throwArity (AFn.java:429)  那么怎么实现上面这种不定参数的问题呢，那就需要用到 \u0026amp; 符号：\n(defn messenger [greeting \u0026amp; who] (println greeting who)) (messenger \u0026quot;aaa\u0026quot; \u0026quot;bbbb\u0026quot; \u0026quot;cccc\u0026quot; \u0026quot;dddd\u0026quot;) ;;------------------------------------------------------ aaa (bbbb cccc dddd)  或许和你的预期不同，clojuer将\u0026amp;符号后面的参数认为是一个列表，因此在打印的时候是按照列表打印的，而没有与第一个参数作为同一个列表。\n匿名函数 匿名函数有两种写法：\n;; 写法一 ((fn [x] (println \u0026quot;Hello, \u0026quot; x)) \u0026quot;Leejoker!\u0026quot;) Hello, Leejoker! user=\u0026gt; nil ;;------------------------------------------------------ ;; 写法二 (#(println \u0026quot;Hello, \u0026quot; %) \u0026quot;Leejoker!\u0026quot;) Hello, Leejoker! user=\u0026gt; nil  那让我们看一下这两种写法的组成吧：\n;; anonymous params body ;; -------- ------ ------------------- (fn [name] (str \u0026quot;Hello, \u0026quot; name) ) ;; anonymous body params ;; -------- ------------ ------- #( (str \u0026quot;Hello, \u0026quot; %1 %2 %\u0026amp;)) ;; 同样，匿名函数里也可以用 \u0026amp; 来定义不定参数列表  当然，你也可以把匿名函数绑定一个函数名：\n(def greet (fn [x] (println \u0026quot;Hello, \u0026quot; x))) ;; 或者是这样 (def greet #(println \u0026quot;Hello, \u0026quot; %)) ;;------------------------------------------------------- (greet \u0026quot;lala\u0026quot;) Hello, lala user=\u0026gt; nil  好用的apply apply可以使一个函数依次调用一个列表中的参数：\n(defn plot [a b] (apply + a b)) (plot 1 '(2 3 4 5)) ;;---------------------------------------- user=\u0026gt; 15  closure clojure的总用看官方文档说应该是用来突破参数作用范围的，这里理解的可能不是很透彻，也希望有大大能够指正，下面是从官方文档中拿来的例子：\n(defn messenger-builder [greeting] (fn [who] (println greeting who))) ; closes over greeting ;; greeting provided here, then goes out of scope (def hello-er (messenger-builder \u0026quot;Hello\u0026quot;)) ;; greeting value still available because hello-er is a closure (hello-er \u0026quot;world!\u0026quot;) ;; Hello world!  java function 最后一部分就是java方法的调用了：\n(defn getlen [obj] (.length obj)) ;;-------------------------------------------- (getlen \u0026quot;123\u0026quot;) user=\u0026gt; 3  下面是官方文档给出的调用方式：\n   Task JAVA Clojure     实例化 Object obj = new Object(\u0026ldquo;foo\u0026rdquo;) (def obj (Object. \u0026ldquo;foo\u0026rdquo;))   实例方法调用 obj.toString() (.toString obj)   实例属性值 obj.field (.-field obj)   静态方法 Math.sqrt(25) (Math/sqrt 25)   静态属性 Math.PI Math/PI    官方文档中习题  Define a function greet that takes not arguments and prints \u0026ldquo;Hello\u0026rdquo;. Replace the _ with the implementation:  (defn greet [] _) ;;--------------------------------- (defn greet [] (println \u0026quot;Hello\u0026quot;))  Redefine greet using def, first with the fn special form and then with the #() reader macro.  ;; using fn (def greet __) ;; using #() (def greet __) ;;------------------------------------------------ (def greet (fn [] (println \u0026quot;Hello\u0026quot;))) (def greet #(println \u0026quot;Hello\u0026quot;))  Define a function greeting which:   Given no arguments, returns \u0026ldquo;Hello, World!\u0026rdquo; Given one argument x, returns \u0026ldquo;Hello, x!\u0026rdquo; Given two arguments x and y, returns \u0026ldquo;x, y!\u0026rdquo;  ;; Hint use the str function to concatenate strings (doc str) (defn greeting ___) ;; For testing (assert (= \u0026quot;Hello, World!\u0026quot; (greeting))) (assert (= \u0026quot;Hello, Clojure!\u0026quot; (greeting \u0026quot;Clojure\u0026quot;))) (assert (= \u0026quot;Good morning, Clojure!\u0026quot; (greeting \u0026quot;Good morning\u0026quot; \u0026quot;Clojure\u0026quot;))) ;;----------------------------------------------------------- (defn greeting ([] (str \u0026quot;Hello, World!\u0026quot;)) ([param] (str \u0026quot;Hello, \u0026quot; param \u0026quot;!\u0026quot;)) ([param1 param2] (str param1 \u0026quot;, \u0026quot; param2 \u0026quot;!\u0026quot;)))  Define a function do-nothing which takes a single argument x and returns it, unchanged.  (defn do-nothing [x] ___) ;;-------------------------------- (defn do-nothing [x] x)  Define a function always-thing which takes any number of arguments, ignores all of them, and returns the keyword :thing.  (defn always-thing [__] ___) ;;--------------------------------- (defn always-thing [\u0026amp; args] :thing) ;; ps: ;; \u0026amp; 符号后面必须有空格才能识别 ;; \u0026amp;args 这样写无效  Define a function make-thingy which takes a single argument x. It should return another function, which takes any number of arguments and always returns x.  (defn make-thingy [x] ___) ;; Tests (let [n (rand-int Integer/MAX_VALUE) f (make-thingy n)] (assert (= n (f))) (assert (= n (f :foo))) (assert (= n (apply f :foo (range))))) ;;--------------------------------------------------------- (defn make-thingy [x] (fn [\u0026amp; args] x))  Define a function triplicate which takes another function and calls it three times, without any arguments.  (defn triplicate [f] ___) ;;---------------------------------- (defn triplicate [f] (f) (f) (f)) ;;PS: ;; 在网上查了一下，问题的翻译是定义一个函数，参数是另一个函数，并在函数体 ;; 中调用3次，大概是这么个意思，刚开始看了好长时间都没明白过来要我做什么，汗  Define a function opposite which takes a single argument f. It should return another function which takes any number of arguments, applies f on them, and then calls not on the result. The not function in Clojure does logical negation.  (defn opposite [f] (fn [\u0026amp; args] ___)) ;;----------------------------- (defn opposite [f] (fn [\u0026amp; args] (not (apply f args))))  Define a function triplicate2 which takes another function and any number of arguments, then calls that function three times on those arguments. Re-use the function you defined in the earlier triplicate exercise.  (defn triplicate2 [f \u0026amp; args] (triplicate ___)) ;;-------------------------------- (defn triplicate2 [f \u0026amp; args] (triplicate (fn [] (apply f args))))  Using the java.lang.Math class (Math/pow, Math/cos, Math/sin, Math/PI), demonstrate the following mathematical facts: The cosine of pi is -1 For some x, sin(x)^2 + cos(x)^2 = 1  (= 1.0 (+ (Math/pow (Math/sin Math/PI) 2) (Math/pow (Math/cos Math/PI) 2))) (= -1.0 (Math/cos Math/PI))  Define a function that takes an HTTP URL as a string, fetches that URL from the web, and returns the content as a string.  ; Hint: Using the java.net.URL class and its openStream method. ; Then use the Clojure slurp function to get the content as a string. (defn http-get [url] ___) (assert (.contains (http-get \u0026quot;http://www.w3.org\u0026quot;) \u0026quot;html\u0026quot;)) ;;----------------------------------------------------------- (defn http-get [url] (slurp (.openStream (java.net.URL. url))))  Define a function one-less-arg that takes two arguments: * f, a function * x, a value and returns another function which calls f on x plus any additional arguments.  (defn one-less-arg [f x] (fn [\u0026amp; args] ___)) ;;----------------------------- (defn one-less-arg [f x] (fn [\u0026amp; args] (apply f x args)))  Define a function two-fns which takes two functions as arguments, f and g. It returns another function which takes one argument, calls g on it, then calls f on the result, and returns that.  (defn two-fns [f g] ___) ;;---------------------------- (defn two-fns [f g] (fn [x] (f (g x)))) ","date":"2018-01-07","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%BA%8C/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其二"},{"content":"简述 　学习clojure的起因主要还是想学习lisp语言吧。由于既想学lisp现阶段又无法脱离jvm这个大的框架,所以就发现了clojure语言，然后就踏上了“自虐”的不归路:D\n学习思路 　在刚开始学习的过程中，我看了很多相关的教程、博客，但总是感觉不得其门而入，简单来说就是找不到这门语言的学习思路。大体是因为clojure和传统的C type语言思路不同吧，再加上语法糖太多，导致各种磕磕碰碰。仔细想想，还是整理一下目前所学，也希望整理的东西能给clojure的初学者提供一定的帮助。\n本系列的笔记是基于官方文档整理、补充的，如有错漏，请在评论区指出，以便及时进行修改，也有助于我自身的提升和进步。\n语言学习的第一步 没错，就是Hello World！\nuser=\u0026gt; (println \u0026quot;Hello, Clojure!\u0026quot;) Hello, Clojure! nil  这一句是在repl中执行的，哦，差点忘了，记得安装lein哦，至于怎么装请自行百度，如果需要梯子，emmmmm，自己想办法吧，程序员或者想成为程序员的人不应该被一面墙阻拦（有人敲门，我去开一下，Σ(っ °Д °;)っ好像有哪里不对）\n言归正传，输出的结果是“Hello, Clojure!”，但方法的返回值是nil，这个输出其实就是函数println的副产物。\n对于clojure的整体认知 下面这一段是我从官方文档中截取的类型说明。\n;; 数字类型 42 ; Long - 64-bit integer (from -2^63 to 2^63-1) 6.022e23 ; Double - double-precision 64-bit floating point 42N ; BigInt - arbitrary precision integer 1.0M ; BigDecimal - arbitrary precision fixed-point decimal 22/7 ; Ratio ;; 字符类型 \u0026quot;hello\u0026quot; ; String \\e ; Character ;; 其他类型 nil ; null value true ; Boolean (also, false) #\u0026quot;[0-9]+\u0026quot; ; Regular expression :alpha ; Keyword :release/alpha ; Keyword with namespace map ; Symbol + ; Symbol - most punctuation allowed clojure.core/+ ; Namespaced symbol ;; 集合 '(1 2 3) ; list [1 2 3] ; vector #{1 2 3} ; set {:a 1, :b 2} ; map  clojure所有的语句都是包含括号的，当然像集合那几个声明方式可以除外（集合那几种同样也是有普通的函数声明方式的）。\n括号内的第一个值是函数体，剩下的值都是这个函数的参数。\n这是clojure最基本的一个概念，也是最重要的一个概念，“函数是一等公民”\n同样，当你想这样使用的时候，他会给你一个错误。\nuser=\u0026gt; (1 2 3) ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  所以你需要使用quote去让clojure知道你不想把它解读成一个函数。\nuser=\u0026gt; (quote (1 2 3)) (1 2 3) ;; 操作同 '(1 2 3) user=\u0026gt; '(1 2 3) (1 2 3)  不过，这样一等公民就变成quote了，哈哈哈哈\n说一下变量 说一下变量的一些概念吧，不然第一篇就这么草草的结束，肯定有人要说我没有干货了XD\n变量的定义主要包含两种，一个是def，另一个是let\ndef类似于全局变量，可以被重新赋值\nlet则相当于局部变量，下面给出了一些例子（感谢clojure-by-example项目提供的例子）。\ndef的使用： user=\u0026gt; (def object \u0026quot;light\u0026quot;) #'user/object user=\u0026gt; (println (str \u0026quot;God said let there be \u0026quot; object)) God said let there be light nil user=\u0026gt; (def object \u0026quot;darkness\u0026quot;) #'user/object user=\u0026gt; (println (str \u0026quot;God said let there be \u0026quot; object)) God said let there be darkness nil  let的使用 user\u0026gt; (let [a \u0026quot;aaa\u0026quot;] (println a)) aaa nil user\u0026gt; (let [a \u0026quot;aaa\u0026quot;] (let [a \u0026quot;AAA\u0026quot;] (println a))) AAA nil user\u0026gt; (let [a \u0026quot;aaa\u0026quot;] (let [a \u0026quot;AAA\u0026quot;] (println a)) (println a)) AAA aaa nil user\u0026gt; (let [a \u0026quot;a\u0026quot;] (let [] (println a))) a nil user=\u0026gt; (let [l \u0026quot;light\u0026quot; d \u0026quot;darkness\u0026quot;] (println (str \u0026quot;God said let there be \u0026quot; l)) (println (str \u0026quot;God also said let there be \u0026quot; d))) God said let there be light God also said let there be darkness nil user\u0026gt; (let [l \u0026quot;light\u0026quot; l_d (str l \u0026quot; and\u0026quot; \u0026quot; darkness\u0026quot;)] (println (str \u0026quot;God also said let there be \u0026quot; l_d))) God also said let there be light and darkness nil  第一篇就这样吧 　第一篇姑且就到这里吧，学习这种函数式语言其实最重要的是对于这种语言有一个正确的认知，然后才是各种语法和应用，如果你始终带着面向对象那种思路反而不太利于clojure的学习。 嘛~ 各位我们下一篇再见！\n","date":"2018-01-06","permalink":"https://leejoker.github.io/post/clojure%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%B6%E4%B8%80/","tags":["clojure","学习笔记"],"title":"clojure学习笔记其一"},{"content":"从disqus到gitment 其实就易用性和使用效果上讲，disqus还是很好用的，只需要注册一个账号，在主题里配置一下就可以了，然而，disqus最大的问题还是在于翻墙，咳，科学上网。今天这个问题我的一个小伙伴也跟我吐槽了，毕竟不是每个人都会去弄个vpn啊，ss啊之类的东西。因此，回家之后果断搞起。\n接下来就是正片了 注册OAuth Application [点此注册] [1]\n填写示例如下图所示：\n填写的重点主要在“Authorization callback URL”，这里应该填你的blog的域名（比如我的就是https://leejoker.github.io）\n注册好之后会获得一个client id和client secret，这个就是用来配置gitment评论与你 GitHub账户关联的信息 。（这个没记住也不要紧，之后也可以在github的settings/Developer settings中找到滴XD） [1]: https://github.com/settings/applications/new \u0026ldquo;注册OAuth Application\u0026rdquo;\n 在主题中配置gitment 我使用的是jacman主题，网上配置gitment的教程大多都是next主题的，因此，特地折腾了一番才配好。当然，使用next主题的同学请自行百度/谷歌教程。\n创建用来存储评论的repo 在GitHub上创建一个repo用来存储评论信息，记得勾上初始化（一开始没勾，结果怎么都不能初始化评论，我真傻，真的QAQ）\n修改jacman评论的布局文件 jacman评论的布局文件在“themes\\jacman\\layout_partial\\post”目录下，打开comment.ejs,将以下代码覆盖原有代码（没错，就是覆盖）。\n\u0026lt;section id=\u0026quot;comments\u0026quot; class=\u0026quot;comment\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;blog_comment\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://imsun.github.io/gitment/style/default.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://imsun.github.io/gitment/dist/gitment.browser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var gitment = new Gitment({ owner: '你的github用户名', repo: '你用来存储评论信息的repo', oauth: { client_id: '之前注册生成的client_id', client_secret: '之前注册生成的client_secret', }, }) gitment.render('blog_comment') \u0026lt;/script\u0026gt; \u0026lt;/section\u0026gt;  这里有一点需要注意的就是“blog_comment”这个id，之前[作者的blog] [2]中的代码用的是“container”作为id的，但是jacman这个主题用来包裹整个文本的div的id就是container，因此，必须修改id才行，否则评论就会出现在正文的正上方(╯‵□′)╯︵┻━┻ [2]: https://imsun.net/posts/gitment-introduction/ \u0026ldquo;Gitment：使用 GitHub Issues 搭建评论系统\u0026rdquo;\n 初始化评论 将配置好的blog发布到github上之后，打开你的任意一篇文章，在最下面点击初始化评论按钮即可。不过这里很不幸的是，你每一篇blog都要手动初始化一下，很蛋疼，目前还没有找到解决的办法，希望后续能解决这个问题。\n","date":"2017-10-11","permalink":"https://leejoker.github.io/post/%E6%8A%98%E8%85%BEhexo%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9C%A8jacman%E9%87%8C%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","tags":["hexo"],"title":"折腾hexo系列之在jacman里集成gitment评论系统"},{"content":"编程的精义 开发是一个阐述思想的过程，把想法转化成逻辑，最后变成代码，就是整个开发的过程。\n编程，是开发的一环，也就是把逻辑转化为代码的过程。\n正如文中所说的那样，“程序=算法+结构”。算法是顺序，分支，循环的组合变化，结构是思想在程序中的映射。因此，代码在编程里是最为easy的一环。\n嘛~~第一章大致就是说了这么一个内容，强调了在编程过程中最为重要的反而是思想，逻辑。掌握语言和转化成代码其实都是最为容易的事。PS:是不是说我只要懂得足够多就能当PPT架构师了:)\n当然，这里说代码是思想的转化自然是没什么问题的，然而写代码同样是一个磨练技艺的过程，怎么写更好，怎么写更易懂，怎么写更容易维护，这也是一个程序猿需要不断去锻炼学习的。PS：这一段与原文主旨没什么关系，只是忽然想到就加上了。不过话说回来，在这方面如果能做到尽善尽美，这让接盘子的人会非常开心吧(o゜▽゜)o☆\n是懒人造就了方法 “懒人”是相对于“愚公”那种“勤快人”而言的，这里都加上了引号，主要还是因为这里都不是明面上的意思，“懒人”不是真正意义上的懒人，“勤快”也并非是什么好事。\n对于开发而言，一味为了完成而做重复的工作是很可怕的，虽然结果可能没什么问题，但是其中的效率和后续要做的工作可能远高于开发时的工作量。\n停下来，做一个会思考的“懒人”在开发中是很有必要的，抽象，方法的调整，不管是对于开发还是后续的维护，都是有益的\n项目管理那些事 我是学管理出身的（不过是信息管理，O(∩_∩)O~），我的管理学老师曾经跟我们说过，“管理学是对人的研究”，管理学不同于其他研究性的学问，更多的关注与人的分工和人与人之间的关系。而对于一个技术出身的人，去做管理，不仅仅是角色的转变，做事方式、承担的责任都会发生变化。\n作为项目管理者，你就是项目的总负责人，如果项目出了问题，你就是责任的承担着，将锅甩给谁都不好使，因为别人看到的就是如此：你带的团队，你接的活，你的项目失败了！仅此而已。\n但往往失败都是能带来成长的，所谓失败是成功之母，不过并非对于所有人来说失败都是成功他母上的XD，只有能够从中发现问题，汲取经验的人，才能够更进一步。所以，项目失败之后不要总是埋怨这个，埋怨那个，更多的应该反思一下自己哪个环境没弄好，是核心人员选的不对？没有按照计划严格执行？团队沟通做的不好？还是自己没有起到好的带头作用？\n说到沟通，从我的感觉来说（毕竟还没做过大的项目呢，/(ㄒoㄒ)/~~ ），越是大的项目，越有可能发生沟通上的问题。为什么这么说呢，简单点来说，就是人多事杂。不同的模块干活的人可能有好几个，他们之间沟通可能是没问题的，但是不同模块的负责人就不一定了，可能这边一个事完了，就继续搞下一个了，但是依赖有更新，接口有变更，这个没及时提，就会造成一些问题。这个只是一个非常浅显的例子，但是实际开发中类似的事情也并非不会发生（或许会很频繁也说不定XD）。\n后续的巴拉巴拉 在后续的内容里作者讨论了人、组织以及关乎项目成败的种种因素，但看完之后隔了一段时间发现还有印象的内容就只剩下“造轮子”的讨论了（莫非我没有管理人员的命ORZ）。\n对于重复造轮子，可能对于很多开发者或者跟我有相似工作经验的开发者而言（我主要做的是交付项目），造轮子是件很没有意义的事情，只有快速找个轮子把任务完成才是最为关键的。\n然而，用了诸多轮子之后发现，当你遇到问题，你还是不得不去把轮子拆开，看看到底里面是怎么做的，然后一通调整，最后，你会发现你把原理弄明白了，然后自己重新做了一个轮子(lll￢ω￢)。\n所以说，重复造轮子并非毫无意义，当你已经成了一个大神，应对各种问题都胸有成竹，那自然重复造轮子就显得是一种时间上的浪费，这是可耻的。可是大多数人都不是大神，很多东西并没有一个成熟的体系化的解决方案，因此，自己造个轮子不但学了技术，更是对自身实力的一种磨练和提升。\n后记 其实在写最后一段内容的时候，离读完这本书已经过去了很长时间了（大概有一个月吧），很多后续内容也没有去仔细品味琢磨。不过从这本书中还是学到了很多东西，不管是技术上的还是管理上的，虽然书中并没有给出问题的解决方案（这点很遗憾），但却留出了很大的思考空间。总体而言是一本很有深度的书籍，我的水平不够就不进一步评价了，喵o(=•ェ•=)m\n嗯，就这样吧，实在不知道写啥了XD\n","date":"2017-08-16","permalink":"https://leejoker.github.io/post/%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","tags":["读书"],"title":"《大道至简》读书笔记"},{"content":"班车上的感慨（人总是莫名伤感233333） 　转眼间已经快工作3年了，年龄也逐渐到达了26岁，我不知道我会在IT这个行业坚持多久，或许是几年也或许是一辈子。人们总是说时光荏苒，白驹过隙。但不仔细回头想想，真的不会发现时间就这样在每天匆忙的上下班中从自己的身后溜走了。 回想过去两年的工作（我是在传统开发行业工作的，互联网接触的不多，主要还是学了没地方用QAQ），虽然在技术上逐渐成熟，也学了很多的东西（想想自己从刚毕业什么都不会，到现在当个开发组的小组长内心还是颇为自豪的23333），框架的，前端的，后端的，也踩了各种坑，但是看看前沿的论坛新闻，感觉自己离这个时代要求的能力还是有不小差距的。不能沉迷于所得的成就，人总是得向前看。 30而立，但看着自己离30岁越来越近，事业上，爱情上都是毫无建树（单身狗。。。哇的一声哭了出来），不禁心里有了些触动，这也是我写这篇博文的动机（估计没什么人愿意看我发牢骚）。\n 多多少少还是要学些东西 　感觉最近多多少少还是要看一些书的（虽然每年都会看，但从没有像今天这样觉得自己这么弱鸡），书单如下大概会像下面这个样子： 1. spring boot in action(至少了解下现在是怎么部署开发微服务的吧，(～￣▽￣)～）�) 2. 自己动手写java虚拟机（这个主要是用来学jvm） 3. hotspot实战（同上，虽然看了些《深入了解java虚拟机》，但是感觉看的发懵） 4. effective go（go还是继续学，虽然办公环境没有互联网的我内心是崩溃的/(ㄒoㄒ)/~~） 5. 张爱玲的一些文集（没想到我是这样的人吧233333） 6. 未来简史（这本书感觉很有趣，正在看） 虽然感觉列多了，但是技术书会尽量看，当然非技术的我一定会看完（请尽情的鄙视我吧）。\n 写着写着莫名心情愉悦了 　没心没肺的人果然还是容易获取快乐，居然写着写着就感觉莫名happy了，算了，反正是随笔性质的东西，姑且写到哪算哪吧，反正没人看23333 最后激励一下自己，嗯，Fight ！！！\n","date":"2017-03-17","permalink":"https://leejoker.github.io/post/26%E5%B2%81%E7%9A%84%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90/","tags":["杂文"],"title":"26岁的细思极恐"},{"content":"Ubuntu下添加ppa仓库 此处以安装atom为例，命令如下：\nsudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom  这样就把atom的仓库添加并安装完成了。\n然而，并没有这么简单\nsudo: add-apt-repository : command not found  mdzz 这是怎么回事，不应该是这样的(╯‵□′)╯︵┻━┻\n解决 百度之后（虽然百度烂但是有些东西还是能查到的），发现还要添加一个python-software-properties包，话说为什么apt仓库要用python的包啊喂(#O′))\n没办法，照办吧，遂执行：\nsudo apt-get install python-software-properties sudo add-apt-repository ppa:webupd8team/atom sudo: add-apt-repository : command not found  什么鬼！！！为什么还是不对，看来依赖还是不足，继续百度，发现还需要安装software-properties-common\n抱着试试的心态执行了一下：\nsudo apt-get install software-properties-common sudo add-apt-repository ppa:webupd8team/atom More info, report packaging bugs, feedback, etc.: http://www.webupd8.org/2014/05/install-atom-text-editor-in-ubuntu-via-ppa.html Report non-packaging Atom bugs here: https://github.com/atom/atom/issues 更多信息： https://launchpad.net/~webupd8team/+archive/ubuntu/atom 按回车继续或者 Ctrl+c 取消添加 gpg: 钥匙环‘/tmp/tmp7nbejmnw/secring.gpg’已建立 gpg: 钥匙环‘/tmp/tmp7nbejmnw/pubring.gpg’已建立 gpg: 下载密钥‘EEA14886’，从 hkp 服务器 keyserver.ubuntu.com gpg: /tmp/tmp7nbejmnw/trustdb.gpg：建立了信任度数据库 gpg: 密钥 EEA14886：公钥“Launchpad VLC”已导入 gpg: 没有找到任何绝对信任的密钥 gpg: 合计被处理的数量：1 gpg: 已导入：1 (RSA: 1) OK  执行成功ㄟ(≧◇≦)ㄏ\n结语 虽然感觉这点很坑（话说包管理添加第三方库为什么还要用其他包啊），但是总算圆满解决了问题，可喜可贺，可喜可贺！\n","date":"2016-10-11","permalink":"https://leejoker.github.io/post/ubuntu%E4%B8%8B%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0ppa%E4%BB%93%E5%BA%93/","tags":["linux"],"title":"Ubuntu下如何添加ppa仓库"},{"content":"这一篇主要说明application.go的主要构成和其中用到方法的主要作用。\n参数定义 application.go中定义了初始化时需要用到的常量和变量\n常量定义： const ( INDEX_CACHE = \u0026quot;index\u0026quot; //各类别下rank ALL_RANK_CACHE = \u0026quot;all_rank\u0026quot; //总的rank BANGUMI_CACHE = \u0026quot;bangumi\u0026quot; //番剧 BANGUMI_LIST_CACHE = \u0026quot;bangumi_list\u0026quot; //新番放松表 SORT_TOP_CACHE = \u0026quot;sort-\u0026quot; //具体某个类别rank(这个在index_cache中要用到) LIVE_INDEX_CACHE = \u0026quot;live_index\u0026quot; //直播rank )  全局变量定义： var ( ProdLevels = []log.Level{ log.InfoLevel, log.NoticeLevel, log.WarnLevel, log.ErrorLevel, log.PanicLevel, log.AlertLevel, log.FatalLevel, } )  这里主要定义了release模式下用到的日志级别。(PS:类库引用的是\u0026quot;github.com/go-playground/log\u0026quot;)\n结构体定义 type BiliBiliApplication struct { Router *gin.Engine //路由 Corn *CornService //初始化服务 Conf *Config //配置信息 Client *client.BCli //客户端 Cache *CacheManager //缓存管理 }  这里定义了Bilibili-go主体程序的结构。\n初始化rank数据并注册任务 application.go中使用了conformTask方法进行了数据的初始化以及任务注册\n//application.go conformTask(app) corn.Start()  conformTask方法如下：\n//application.go func conformTask(app *BiliBiliApplication) { app.Corn.RegisterTask(\u0026amp;IndexInfoTask{CornTask: CornTask{Name: \u0026quot;index_info\u0026quot;, Duration: 2 * time.Hour}, app: app}) app.Corn.RegisterTask(\u0026amp;BangumiInfoTask{CornTask: CornTask{Name: \u0026quot;bangumi_info\u0026quot;, Duration: 6 * time.Hour}, app: app}) app.Corn.RegisterTask(\u0026amp;BangumiListTask{CornTask: CornTask{Name: \u0026quot;bangumi_list\u0026quot;, Duration: 6 * time.Hour}, app: app}) app.Corn.RegisterTask(\u0026amp;TopRankTask{CornTask: CornTask{Name: \u0026quot;top_rank\u0026quot;, Duration: 2 * time.Hour}, app: app}) app.Corn.RegisterTask(\u0026amp;LiveIndexTask{CornTask: CornTask{Name: \u0026quot;alive_index\u0026quot;, Duration: 2 * time.Hour}, app: app}) }  从方法名上看是调用了CornService中的RegisterTask(注册任务)的方法，那么，我们看一下这个RegisterTask方法到底做了些什么吧。\n//corn.go //execute task func exec(f CornTaskImpl) { log.Info(\u0026quot;invoke task, taskname: \u0026quot;, f.GetName()) defer func() { if r := recover(); r != nil { log.Error(r) } }() if err := f.Run(); err != nil { f.Failure(err) } else { f.Success() } log.Info(\u0026quot;run task end, taskname: \u0026quot;, f.GetName()) } //这里就是那个名为注册任务的方法 func (c *CornService) RegisterTask(task CornTaskImpl) { task.SyncLastRunTime() exec(task) c.tasks = append(c.tasks, task) }  不难发现，实际上这个注册任务的方法就是将task执行了一下，然后放到c.tasks数组里。\n而之后的corn.Start()方法：\n//corn.go func (c *CornService) syncTaskList(nowTime time.Time) { for _, task := range c.tasks { //循环任务列表 //Unix timestamp =\u0026gt; duration between := time.Duration(nowTime.Unix()-task.GetLastRun().Unix()) * time.Second if between \u0026gt;= task.GetDuration() { //当时间间隔大于设定的时间周期则执行,并修改LastRun的值 task.SyncLastRunTime() exec(task) } } } func (c *CornService) loop() { for { select { case \u0026lt;-c.done: log.Info(\u0026quot;corn loop stopped....\u0026quot;) return case nowTime := \u0026lt;-c.ticker.C: //这里通过计时器获取到当前时间 go c.syncTaskList(nowTime) } } } func (c *CornService) Start() { go c.loop() }  corn.Start()方法开启了一个loop线程，这个线程简单的来说就是每隔一分钟执行一次syncTaskList方法。\n到此，bilibili-go这个小项目的学习也基本上告一段落了，剩下的内容基本上都是数据获取和处理的部分。这个项目虽然很小，但是对多线程的学习，go的基础都有很大的帮助，在此也感谢WhiteBlue大大，(^_^)\n","date":"2016-09-28","permalink":"https://leejoker.github.io/post/bilibili-go%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","tags":["go","bilibili"],"title":"bilibili-go项目源码学习笔记_2"},{"content":"bilibili-go服务加载流程浅析 main.go中使用了service包中的application.go创建了新的应用，进而开启了bilibili-go服务，并监听了8080端口。代码如下：\npackage main import ( \u0026quot;github.com/go-playground/log\u0026quot; \u0026quot;github.com/whiteblue/bilibili-go/service\u0026quot; ) func main() { app, err := service.NewApplication(\u0026quot;conf.json\u0026quot;) if err != nil { log.Fatal(err) } app.Router.Run(\u0026quot;:8080\u0026quot;) }  在application.go中，使用了gin作为web框架，并依次执行了以下操作：\n首先读取了appkey和secret，\nconf, err := ReadConfigFromFile(configFile)  设置日志，\ncLog := console.New() if conf.Debug { log.RegisterHandler(cLog, log.AllLevels...) gin.SetMode(gin.DebugMode) } else { log.RegisterHandler(cLog, ProdLevels...) gin.SetMode(gin.ReleaseMode) }  加载了gin的中间件，\nr := gin.New() //use gzip r.Use(gin.Recovery()) r.Use(gzip.Gzip(gzip.BestCompression))  启动了CornService用于初始化数据（主要初始化了各类别下的rank数据），\n//corn service corn := NewCornService()  创建了bilibiliClient，\n//bilibili client cli := client.NewClient(conf.Appkey, conf.Secret)  启动了缓存管理,\ncache := NewCacheManager()  最后建立app，并执行了初始化操作,\n//建立app应用 app := \u0026amp;BiliBiliApplication{Router: r, Corn: corn, Conf: conf, Client: cli, Cache: cache} //加载路由 ConformRoute(app) log.Info(\u0026quot;conform route\u0026quot;) //进行rank数据初始化 conformTask(app) corn.Start() log.Info(\u0026quot;conform task\u0026quot;) log.Info(\u0026quot;init complete, start listen...\u0026quot;)  完整代码如下：\nfunc NewApplication(configFile string) (*BiliBiliApplication, error) { conf, err := ReadConfigFromFile(configFile) if err != nil { return nil, err } cLog := console.New() if conf.Debug { log.RegisterHandler(cLog, log.AllLevels...) gin.SetMode(gin.DebugMode) } else { log.RegisterHandler(cLog, ProdLevels...) gin.SetMode(gin.ReleaseMode) } log.Info(\u0026quot;conform config file\u0026quot;) r := gin.New() //use gzip r.Use(gin.Recovery()) r.Use(gzip.Gzip(gzip.BestCompression)) //corn service corn := NewCornService() //bilibili client cli := client.NewClient(conf.Appkey, conf.Secret) cache := NewCacheManager() app := \u0026amp;BiliBiliApplication{Router: r, Corn: corn, Conf: conf, Client: cli, Cache: cache} ConformRoute(app) log.Info(\u0026quot;conform route\u0026quot;) conformTask(app) corn.Start() log.Info(\u0026quot;conform task\u0026quot;) log.Info(\u0026quot;init complete, start listen...\u0026quot;) return app, nil }  通过路由和初始化的rank数据，就可以获取相应的列表以及视频信息了。\n","date":"2016-09-27","permalink":"https://leejoker.github.io/post/bilibili-go%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","tags":["go","bilibili"],"title":"bilibili-go项目源码学习笔记_1"},{"content":"为什么要写这个 最近对go语言萌生了不小的学习欲望，因而找了一本书开始看，看到指针一节，不禁再次想起了那些被c语言支配的恐怖日子（这也是我选择java的原因啊，（╯' - \u0026lsquo;)╯︵ ┻━┻ ）。不过，经过再次整理之后发现其实指针这个概念还是蛮好理解的，也希望这篇小文章能给那些难以理解指针的童鞋一点帮助（没帮倒忙就好，o(╯□╰)o），下面就来详细说明一番。\n指针概念解析 指针的概念其实主要分为两个部分，一个是内存地址，另一个则是内存地址指向的值。举个栗子：\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r)\rfunc main() {\ra := 3\rb := 5\rfmt.Println(a, b) //输出值：3 5\r}\r 对于变量a而言，\u0026amp;a就是内存中变量a的地址。那么我们如何通过内存中的地址获取到值呢，看下面代码：\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r)\rfunc main() {\ra := 3\rc := \u0026amp;a\rfmt.Println(*c) //输出值：3\r}\r 我们将a的内存地址\u0026amp;a赋给变量c，通过c就取出了地址\u0026amp;a中的值，因此通过就可以将相应地址的值取出了。\n总结 *和\u0026amp;是一对相对的概念，\u0026amp;代表地址，*代表地址对应的值，因此一个变量\na := 3\r \u0026amp;a代表了变量a内存地址，而a的值就可以写作*\u0026amp;a了。怎么样，是不是很简单（本来就很简单啦，果然还是自己太笨了，╮(╯▽╰)╭）\n","date":"2016-09-21","permalink":"https://leejoker.github.io/post/%E5%AF%B9%E4%BA%8Ego%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/","tags":["go"],"title":"对于Go语言中指针的思路整理"},{"content":"div旋转﻿ \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\r.hexHead {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\r-webkit-transform: rotate(60deg); \u0026lt;!--这里旋转60度--\u0026gt;\rmargin-left: 48px;\r}\r.hexCenter {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\rmargin-left: 48px;\rmargin-top:-138px;\r}\r.hexBottom {\rwidth:80px;\rheight:138px;\rbackground-color: chartreuse;\r-webkit-transform: rotate(-60deg);\rmargin-left: 48px;\rmargin-top:-138px;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div class=\u0026quot;hexHead\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hexCenter\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hexBottom\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 控制边框 \u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;Draw Hive\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt;\r.hiveTop {\rwidth: 0;\rborder: 30px solid #6C6;\rborder-top: none;\rborder-bottom: 30px solid #6C6;\rborder-left: 52px solid transparent;\rborder-right: 52px solid transparent;\r}\r.hiveCenter {\rwidth: 104px;\rheight: 60px;\rbackground-color: #6C6;\r}\r.hiveBottom {\rwidth: 0;\rborder: 30px solid #6C6;\rborder-bottom: none;\rborder-top: 30px solid #6C6;\rborder-left: 52px solid transparent;\rborder-right: 52px solid transparent;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveTop\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveCenter\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;hiveBottom\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r css实现 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;六边形\u0026lt;/title\u0026gt;\r\u0026lt;style\u0026gt;\r.wrap {\rmargin: 100px;\rwidth: 303px;\r}\r.nav {\rwidth: 100px;\rheight: 58px;\rbackground: #339933;\rdisplay: inline-block;\rposition: relative;\rline-height: 58px;\rtext-align: center;\rcolor: #ffffff;\rfont-size: 14px;\rtext-decoration: none;\rfloat: left;\rmargin-top: 31px;\rmargin-right: 1px;\r}\r.nav s {\rwidth: 0;\rheight: 0;\rdisplay: block;\roverflow: hidden;\rposition: absolute;\rborder-left: 50px dotted transparent;\rborder-right: 50px dotted transparent;\rborder-bottom: 30px solid #339933;\rleft: 0px;\rtop: -30px;\r}\r.nav b {\rwidth: 0;\rheight: 0;\rdisplay: block;\roverflow: hidden;\rposition: absolute;\rborder-left: 50px dotted transparent;\rborder-right: 50px dotted transparent;\rborder-top: 30px solid #339933;\rbottom: -30px;\rleft: 0px;\r}\r.a0 {\rmargin-left: 100px;\r}\r.a1 {\rmargin-left: 50px;\r}\r.nav:hover {\rbackground: #8CBF26;\rcolor: #333333;\r}\r.nav:hover s {\rborder-bottom-color: #8CBF26;\r}\r.nav:hover b {\rborder-top-color: #8CBF26;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;wrap\u0026quot;\u0026gt;\r\u0026lt;a class=\u0026quot;nav a0\u0026quot; target=\u0026quot;_blank\u0026quot; href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;s\u0026gt;\u0026lt;/s\u0026gt;广播\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 图就不展示了，就结果而言，三者都可以产生六边形的按钮，但是显而易见第三种更适合用来做为按钮使用。\n第一种：要用到三个div，需添加多个相同超链接才能够达到覆盖整个六边形的目的 第二种：上下两个div宽度全是0，且也是三个div 第三种：方便易用，但是是用绝对定位处理的，这可能在后期调整上对于像我这种前端苦手而言或许会带来一些苦难QAQ\n","date":"2016-09-21","permalink":"https://leejoker.github.io/post/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%8C%89%E9%92%AE/","tags":["CSS"],"title":"如何创建六边形按钮"}]
>>>>>>> be0b0d36c3ff3fd389bdbf6a0efe6ac39ad654c7
